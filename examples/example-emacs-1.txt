;;TODO: reminders
;; - install helm
;; - rtags - C/C++ indexer - https://github.com/Andersbakken/rtags
;; - company mode? - text completion - https://company-mode.github.io/
;; - modularize emacs config to keep it organized:
;; -  put it on a git repo in github
;; -  make sure it works on other machines just by pasting it

;; reminders end

;; these are the packages you use
;; package repo - package-name
;; ------- Table Start ---------
;;
;; melpa - expand-region
;; melpa - dumb-jump
;; (not yet) melpa - helm

;; ------- Table End -----------

;; Added by Package.el.  This must come before configurations of
;; installed packages.  Don't delete this line.  If you don't want it,
;; just comment it out by adding a semicolon to the start of the line.
;; You may delete these explanatory comments.
(package-initialize)

(require 'package)

(setq package-enable-at-startup nil)

(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))

(package-initialize)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package)
  (package-install 'expand-region)
  (package-install 'dumb-jump))
;;   (package-install 'lsp-mode)
;;   (package-install 'yasnippet))

;; (use-package company-lsp
;;     :ensure t
;;     :config
;;     (require 'company-lsp)
;;     (push 'company-lsp company-backends)
;;     (add-hook 'after-init-hook 'global-company-mode))

;; (use-package lsp-mode
;;   :ensure t
;;   :config
;;   (require 'lsp-mode)
;;   (require 'lsp-clients)
;;   (add-hook 'c++-mode-hook 'lsp)
;;   (add-hook 'c-mode-hook 'lsp))

;; (require 'lsp-mode)
;; (add-hook 'c++-mode-hook #'lsp)
;; (require 'company-lsp)
;; (push 'company-lsp company-backends)

;;NOTE: MUST have icicles-install.el downloaded on this path:
;; (load "~/dev/emacs/icicles-install")
;; (add-to-list 'load-path "~/icicles/")
;; (require 'icicles)
;; (icy-mode 1)




(menu-bar-mode -1)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(setq inhibit-startup-screen t)
(tool-bar-mode -1)
(toggle-scroll-bar -1)
(setq-default c-default-style "linux")
(setq-default c-basic-offset 2)
(c-set-offset 'inline-open '0)
(transient-mark-mode -1)

(dumb-jump-mode)

;; IDO Mode
(setq ido-file-extensions-order '(".cpp" ".c" ".h" ""))
(setq ido-ignore-directories '(".git") )
(setq ido-ignore-extensions t)
;; (add-to-list 'completion-ignored-extensions "" t)
(ido-mode t)
;; /IDO Mode

      

(defun font-exists-p (font) "check if font exists" (if (null (x-list-fonts font)) nil t))

(defun is-windows ()
  (string-equal system-type "windows-nt"))

(defun is-linux ()
  (string-equal system-type "gnu/linux"))

;; Windows
(if (is-windows)
    (progn
      (if (font-exists-p "Liberation Mono")
	  (progn (set-default-font "Liberation Mono")
		 (set-face-attribute 'default nil :height 125 :weight 'Regular)))))
;; Linux
(if (is-linux)
    (progn
      ;; (if (font-exists-p "Ubuntu Mono")
      ;; 	  (progn (set-default-font "Ubuntu Mono")
      ;; 		 (set-face-attribute 'default nil :height 135 :weight 'Regular))
      ;; 	(set-face-attribute 'default nil  :height 140 :weight 'Regular))
      (if (string= default-directory "~/")
	  (setq default-directory "~/dev/"))))

(set-face-attribute 'default nil :height 125 :weight 'Regular)

;; (setq fontname "SFNS Display")
(setq visible-bell 1)
(icomplete-mode 1)

;; split only vertically
(defun display-new-buffer (buffer force-other-window)
  "If BUFFER is visible, select it.
If it's not visible and there's only one window, split the
current window and select BUFFER in the new window. If the
current window (before the split) is more than 100 columns wide,
split horizontally(left/right), else split vertically(up/down).
If the current buffer contains more than one window, select
BUFFER in the least recently used window.
This function returns the window which holds BUFFER.
FORCE-OTHER-WINDOW is ignored."
  (or (get-buffer-window buffer)
    (if (one-window-p)
        (let ((new-win
               (if (> (window-width) 50)
                   (split-window-horizontally)
                 (split-window-vertically))))
          (set-window-buffer new-win buffer)
          new-win)
      (let ((new-win (get-lru-window)))
        (set-window-buffer new-win buffer)
        new-win))))
;; use display-buffer-alist instead of display-buffer-function if the following line won't work
(setq display-buffer-function 'display-new-buffer)

;; (setq-default indent-tabs-mode nil)

;; (setq tab-always-indent 'complete)
(setq c-tab-always-indent 'complete)
(global-hl-line-mode +1)

;; setting shader files to c++ major mode
(add-to-list 'auto-mode-alist '("\\.vert\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.frag\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.shader\\'" . c++-mode))

(column-number-mode 1)

;; backup files
(setq backup-directory-alist `(("." . "~/.saves")))
(setq backup-by-copying t)

;;NOTE: compiling code - start

(defun get-current-folder-name ()
  (interactive)
  (if (eq (string-match "/\\([^/]*\\)/$" default-directory) nil) nil
    (substring default-directory
	       (match-beginning 1)
	       (match-end 1))))

(defun get-current-folder-index ()
  (interactive)
  (if (eq (string-match "/\\([^/]*\\)/$" default-directory) nil) nil
     (match-end 1)))

;;NOTE: goes to folder that meets the condition cond
(defun goto-folder (condition)
  (let ((max-subdirs 4)
	(past-dir default-directory)
	(folder-index 0))
    (change-default-dir
     (lambda () (catch 'not-found
		  (while (not (funcall condition))
		    (cd "../")
		    (setq max-subdirs (- max-subdirs 1))
		    (if (= max-subdirs 0)
			(throw 'not-found -1)))
		  0)))))

;;NOTE: changes default-directory safely
;;        if it goes something wrong, default-directory
;;        will go back to how it was before         
(defun change-default-dir (callback)
  (let ((temp-dir default-directory)
	(ret-code 0))
    (setq ret-code (funcall callback))
    (if (= ret-code -1)
	(setq default-directory temp-dir))
    ret-code))


(defun is-playground-cpp ()
  (let ((is-pg nil)
	(folder-index -1)
	(temp-def-dir ""))
    (setq temp-def-dir default-directory)	
    (setq is-pg (goto-folder
		   (lambda () (or (string= (get-current-folder-name)
					   "cpp playground")
				  (string= (get-current-folder-name)
					   "c-playground")))))
    (if (= is-pg 0)
	(setq is-pg t)
      (setq is-pg nil))

    (setq folder-index (get-current-folder-index))
    (setq default-directory temp-def-dir)

    (mv-ret is-pg folder-index)))



(defun is-playground-lua ()
  (let ((is-pg nil)
	(folder-index -1))
    (setq is-pg (goto-folder
		   (lambda () (string= (get-current-folder-name)
				     "lua-playground"))))
    (if (= is-pg 0)
	(setq is-pg t)
      (setq is-pg nil))

    (setq folder-index (get-current-folder-index))

    (mv-ret is-pg folder-index)))

(defun run-cpp-file (folder-index cpp-file-name)
  ;;building command string
  (message "buffer-file-name: %s" (buffer-file-name))
  (compile (concat
	    "runcpp "
	    (buffer-file-name))))

(defun run-lua-file (lua-filename)
  (compile (concat
	    "lua "
	    lua-filename)))

(defun get-build-file ()
  (if (is-windows)
      "build.bat"
    "build.sh"))

(defun get-build-command()
  (cond ((and (is-windows) (file-exists-p "build.bat")) "build")
	((and (is-linux) (file-exists-p "build.sh")) "./build.sh")
	((file-exists-p "Makefile") "make")))

;;NOTE: finds the build.bat and runs it
(defun compile-proj ()
  (if (eq (goto-folder
	   (lambda () (or (file-exists-p (get-build-file))
			  (file-exists-p "Makefile")))) 0)
      (compile (get-build-command))
    (message "compile error: build file not found")))
  
(defun matt-compile ()
  (interactive)
  (if (get-buffer "*compilation*")
      (kill-buffer "*compilation*"))
  (mv-let (is-pg-cpp folder-index) (is-playground-cpp)
    (save-buffer (not compilation-ask-about-save))
    (cond
     (is-pg-cpp
      (run-cpp-file folder-index (buffer-name)))
     ((is-playground-lua)
      (run-lua-file (buffer-name)))
     (t (compile-proj)))))

    ;; (if is-pg-cpp
    ;; 	(run-cpp-file folder-index (buffer-name))
    ;;   (compile-proj))))

(global-set-key (kbd "M-m") 'matt-compile)

;;NOTE: compiling code - - end

(global-set-key (kbd "M-<f4>") 'save-buffers-kill-emacs)
(global-set-key (kbd "C-M-m") 'eval-buffer)

(defun er-switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(defun gen-ctags ()
  (interactive)
  (shell-command "ctags -e -R")
  )

;; Overriding default keybindings that I use a lot

;; free-keys to look for free key combinations
;; view-lossage to look at the name of the last commands

;; C-M-g jump to definition
;; C-M-p jump back
;; C-x 0 join window

;; j-todo-controls
;;   (define-key hl-todo-mode-map (kbd "C-c p") 'hl-todo-previous)
;;   (define-key hl-todo-mode-map (kbd "C-c n") 'hl-todo-next)
;;   (define-key hl-todo-mode-map (kbd "C-c o") 'hl-todo-occur)

(defun open-messages ()
  (interactive)
  (switch-to-buffer-other-window "*Messages*")
  (other-window 1))


(defun open-scratch ()
  (interactive)
  (switch-to-buffer-other-window "*scratch*"))

(defun back-to-other-buffer()
  (interactive)
  (switch-to-buffer nil))

(defun kill-current-buffer()
  (interactive)
  (kill-buffer nil))

;;NOTE: hotkey reminders (default emacs)
;; C-x C-v RET - reload buffer

;;NOTE: custom keybindings
(global-set-key (kbd "C-;") 'find-file)
(global-set-key (kbd "C-:") 'find-file-other-window)
(global-set-key (kbd "C-,") 'back-to-other-buffer)
(global-set-key (kbd "C-x ,") 'clone-indirect-buffer)
(global-set-key (kbd "C-'") 'other-window)
(global-set-key (kbd "C-.") 'switch-to-buffer)
(global-set-key (kbd "C->") 'switch-to-buffer-other-window)
(global-set-key (kbd "C-\"") 'kill-current-buffer)
(global-set-key (kbd "M-n") 'save-buffer)
(global-set-key (kbd "C-M-;") 'previous-error)
(global-set-key (kbd "C-M-'") 'next-error)
(global-set-key (kbd "M-p") 'ff-find-other-file)
(global-set-key (kbd "C-x m") 'open-messages)
(global-set-key (kbd "C-x s") 'open-scratch)
(global-set-key (kbd "C-\]") 'idomenu)


;; (global-set-key (kbd "C-M-g") 'gen-ctags)

;;NOTE: highlight matching parens
(setq show-paren-delay 0)
(show-paren-mode)

;; (setq show-paren-when-point-inside-paren 1)

(define-advice show-paren-function (:around (fn) fix)
  "Highlight enclosing parens."
  (cond ((looking-at-p "\\s(") (funcall fn))
        (t (save-excursion
             (ignore-errors (backward-up-list))
             (funcall fn)))))

(require 'expand-region)
(global-set-key (kbd "C-=") 'er/expand-region)

(setq visible-bell       nil
      ring-bell-function #'ignore)

;;NOTE: my custom code ends here. rest is package code ----- END -----------------

;;ctags command is 'ctags -e -R'
;; Highlight TODOs and others

;;; hl-todo.el --- highlight TODO and similar keywords  -*- lexical-binding: t -*-

;; Copyright (C) 2013-2018  Jonas Bernoulli

;; Author: Jonas Bernoulli <jonas@bernoul.li>
;; Homepage: https://github.com/tarsius/hl-todo
;; Keywords: convenience

;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; For a full copy of the GNU General Public License
;; see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Highlight TODO and similar keywords in comments and strings.

;; You can either turn on `hl-todo-mode' in individual buffers or use
;; the the global variant `global-hl-todo-mode'.  Note that the option
;; `hl-todo-activate-in-modes' controls in what buffers the local mode
;; will be activated if you do the latter.  By default it will only be
;; activated in buffers whose major-mode derives from `prog-mode'.

;; This package also provides commands for moving to the next or
;; previous keyword and to invoke `occur' with a regexp that matches
;; all known keywords.  If you want to use these commands, then you
;; should bind them in `hl-todo-mode-map', e.g.:
;;
;;   (define-key hl-todo-mode-map (kbd "C-c p") 'hl-todo-previous)
;;   (define-key hl-todo-mode-map (kbd "C-c n") 'hl-todo-next)
;;   (define-key hl-todo-mode-map (kbd "C-c o") 'hl-todo-occur)

;; See [[https://www.emacswiki.org/emacs/FixmeMode][this list]] on the Emacswiki for other packages that implement
;; the same basic features, but which might also provide additional
;; features that you might like, but which I don't deem necessary.

;;; Code:

(defgroup hl-todo nil
  "Highlight TODO and similar keywords in comments and strings."
  :group 'font-lock-extra-types)

(defface hl-todo
  '((t (:bold t :foreground "#cc9393")))
  "Base face used to highlight TODO and similar keywords.
The faces used to highlight certain keywords are, by default,
created by inheriting this face and using the appropriate
color specified using the option `hl-todo-keyword-faces' as
foreground color."
  :group 'hl-todo)

(defcustom hl-todo-activate-in-modes '(prog-mode text-mode)
  "Major-modes in which `hl-todo-mode' should be activated.

This is used by `global-hl-todo-mode', which activates
`hl-todo-mode' in all buffers whose major-mode derived from one
of the modes listed here.

Even though `org-mode' indirectly derives from `text-mode' this
mode is never activated in `org-mode' buffers because that mode
provides its own TODO keyword handling."
  :package-version '(hl-todo . "2.1.0")
  :group 'hl-todo
  :type '(repeat function))

(defcustom hl-todo-text-modes '(text-mode)
  "Major-modes that are considered text-modes.

In buffers whose major-mode derives from one of the modes listed
here TODO keywords are always highlighted even if they are not
located inside a string."
  :package-version '(hl-todo . "2.1.0")
  :group 'hl-todo
  :type '(repeat function))

(defcustom hl-todo-keyword-faces
  '(("HOLD" . "#d0bf8f")
    ("TODO" . "#cc9393")
    ("NEXT" . "#dca3a3")
    ("THEM" . "#dc8cc3")
    ("PROG" . "#7cb8bb")
    ("OKAY" . "#7cb8bb")
    ("DONT" . "#5f7f5f")
    ("FAIL" . "#8c5353")
    ("DONE" . "#afd8af")
    ("NOTE"   . "#d0bf8f")
    ("KLUDGE" . "#d0bf8f")
    ("HACK"   . "#d0bf8f")
    ("TEMP"   . "#d0bf8f")
    ("FIXME"  . "#cc9393")
    ("XXX"    . "#cc9393")
    ("XXXX"   . "#cc9393")
    ("???"    . "#cc9393"))
  "Faces used to highlight specific TODO keywords."
  :package-version '(hl-todo . "2.0.0")
  :group 'hl-todo
  :type '(repeat (cons (string :tag "Keyword")
                       (choice :tag "Face   "
                               (string :tag "Color")
                               (sexp :tag "Face")))))

(defcustom hl-todo-highlight-punctuation ""
  "String of characters to highlight after keywords.

Each of the characters appearing in this string is highlighted
using the same face as the preceeding keyword when it directly
follows the keyword.

Characters whose syntax class is `w' (which means word),
including alphanumeric characters, cannot be used here."
  :package-version '(hl-todo . "2.0.0")
  :group 'hl-todo
  :type 'string)

(defvar-local hl-todo--regexp nil)
(defvar-local hl-todo--keywords nil)

(defun hl-todo--setup ()
  (setq hl-todo--regexp
        (concat "\\(\\<"
                (regexp-opt (mapcar #'car hl-todo-keyword-faces) t)
                "\\>"
                (and (not (equal hl-todo-highlight-punctuation ""))
                     (concat "[" hl-todo-highlight-punctuation "]*"))
                "\\)"))
  (setq hl-todo--keywords
        `(((lambda (bound) (hl-todo--search nil bound))
           (1 (hl-todo--get-face) t t))))
  (font-lock-add-keywords nil hl-todo--keywords t))

(defvar hl-todo--syntax-table (copy-syntax-table text-mode-syntax-table))

(defun hl-todo--search (&optional regexp bound backward)
  (unless regexp
    (setq regexp hl-todo--regexp))
  (and (let ((case-fold-search nil))
         (with-syntax-table hl-todo--syntax-table
           (funcall (if backward #'re-search-backward #'re-search-forward)
                    regexp bound t)))
       (or (apply #'derived-mode-p hl-todo-text-modes)
           (nth 8 (syntax-ppss)) ; inside comment or string
           (and (or (not bound)
                    (funcall (if backward #'< #'>) bound (point)))
                (hl-todo--search regexp bound backward)))))

(defun hl-todo--get-face ()
  (let ((face (cdr (assoc (match-string 2) hl-todo-keyword-faces))))
    (if (stringp face)
        (list :inherit 'hl-todo :foreground face)
      face)))

(defvar hl-todo-mode-map (make-sparse-keymap)
  "Keymap for `hl-todo-mode'.")

;;;###autoload
(define-minor-mode hl-todo-mode
  "Highlight TODO and similar keywords in comments and strings."
  :lighter ""
  :keymap hl-todo-mode-map
  :group 'hl-todo
  (if hl-todo-mode
      (hl-todo--setup)
    (font-lock-remove-keywords nil hl-todo--keywords))
  (when font-lock-mode
    (save-excursion
      (goto-char (point-min))
      (while (hl-todo--search)
        (save-excursion
	  (font-lock-fontify-region (match-beginning 0) (match-end 0) nil))))))

;;;###autoload
(define-globalized-minor-mode global-hl-todo-mode
  hl-todo-mode hl-todo--turn-on-mode-if-desired)

(defun hl-todo--turn-on-mode-if-desired ()
  (when (and (apply #'derived-mode-p hl-todo-activate-in-modes)
             (not (derived-mode-p 'org-mode)))
    (hl-todo-mode 1)))

;;;###autoload
(defun hl-todo-next (arg)
  "Jump to the next TODO or similar keyword.
The prefix argument ARG specifies how many keywords to move.
A negative argument means move backward that many keywords."
  (interactive "p")
  (if (< arg 0)
      (hl-todo-previous (- arg))
    (while (and (> arg 0)
                (not (eobp))
                (progn
                  (when (let ((case-fold-search nil))
                          (looking-at hl-todo--regexp))
                    (goto-char (match-end 0)))
                  (or (hl-todo--search)
                      (user-error "No more matches"))))
      (cl-decf arg))))

;;;###autoload
(defun hl-todo-previous (arg)
  "Jump to the previous TODO or similar keyword.
The prefix argument ARG specifies how many keywords to move.
A negative argument means move forward that many keywords."
  (interactive "p")
  (if (< arg 0)
      (hl-todo-next (- arg))
    (while (and (> arg 0)
                (not (bobp))
                (let ((start (point)))
                  (hl-todo--search (concat hl-todo--regexp "\\=") nil t)
                  (or (hl-todo--search nil nil t)
                      (progn (goto-char start)
                             (user-error "No more matches")))))
      (goto-char (match-end 0))
      (cl-decf arg))))

;;;###autoload
(defun hl-todo-occur ()
  "Use `occur' to find all TODO or similar keywords.
This actually finds a superset of the highlighted keywords,
because it uses a regexp instead of a more sophisticated
matcher."
  (interactive)
  (occur hl-todo--regexp))

;;; _
(provide 'hl-todo)
;; Local Variables:
;; indent-tabs-mode: nil
;; End:
;;; hl-todo.el ends here

;; todo hotkeys
(define-key hl-todo-mode-map (kbd "C-c p") 'hl-todo-previous)
(define-key hl-todo-mode-map (kbd "C-c n") 'hl-todo-next)
(define-key hl-todo-mode-map (kbd "C-c o") 'hl-todo-occur)

(global-hl-todo-mode)

;;; sunburn-theme.el --- A low contrast color theme

;; Copyright © 2017 Martín Varela
;; Copyright (C) 2011-2016 Bozhidar Batsov (zenburn-theme.el)

;; Author: Martín Varela (martin@varela.fi)
;; URL: http://github.com/mvarela/Sunburn-Theme
;; Version: 1.0
;; Package-Requires: ((emacs "24"))

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; A port of the popular Vim theme Zenburn for Emacs 24, built on top
;; of the new built-in theme support in Emacs 24.

;;; Credits:

;; This code is based off Bozhidar Batsov's port of the Zenburn theme

;;; Code:

(deftheme sunburn "The Sunburn color theme")

;;; Color Palette

(defvar sunburn-default-colors-alist
  '(("sunburn-fg+1"     . "#f1f1f1")
    ("sunburn-fg"       . "#dedded")
    ("sunburn-fg-1"     . "#aeadbd")
    ("sunburn-bg-2"     . "#383339")
    ("sunburn-bg-1"     . "#433844")
     ;;NOTE: sunburn bg - background color
    ("sunburn-bg-05"    . "#222222") ;; hl-line
    ;; ("sunburn-bg"       . "#484349") ;; bg
    ("sunburn-bg"       . "#111111")
    ("sunburn-bg+05"    . "#373664")
    ("sunburn-bg+1"     . "#686369")
    ("sunburn-bg+2"     . "#787379")
    ("sunburn-bg+3"     . "#888389")
    ("sunburn-red+1"    . "#DCA3A3")
    ("sunburn-red"      . "#CC9393")
    ("sunburn-red-1"    . "#BC8383")
    ("sunburn-red-2"    . "#AC7373")
    ("sunburn-red-3"    . "#9C6363")
    ("sunburn-red-4"    . "#8C5353")
    ("sunburn-orange"   . "#DFAF8F")
    ("sunburn-yellow"   . "#F0DFAF")
    ("sunburn-yellow-1" . "#E0CF9F")
    ("sunburn-yellow-2" . "#D0BF8F")
    ("sunburn-gold"     . "#eead0e")
    ("sunburn-green-1"  . "#5F7F5F")
    ("sunburn-green"    . "#7F9F7F")
    ("sunburn-green+1"  . "#8FB28F")
    ("sunburn-green+2"  . "#9FC59F")
    ("sunburn-green+3"  . "#AFD8AF")
    ("sunburn-green+4"  . "#BFEBBF")
    ("sunburn-cyan"     . "#a7a6d4")
    ("sunburn-blue+1"   . "#9796c4")
    ("sunburn-blue"     . "#8786b4")
    ("sunburn-blue-1"   . "#777694")
    ("sunburn-blue-2"   . "#676694")
    ("sunburn-blue-3"   . "#575684")
    ("sunburn-blue-4"   . "#474674")
    ("sunburn-blue-5"   . "#373664")
    ("sunburn-magenta"  . "#b48ead"))
  "List of Sunburn colors.
Each element has the form (NAME . HEX).

`+N' suffixes indicate a color is lighter.
`-N' suffixes indicate a color is darker.")

(defvar sunburn-override-colors-alist
  '()
  "Place to override default theme colors.

You can override a subset of the theme's default colors by
defining them in this alist before loading the theme.")

(defvar sunburn-colors-alist
  (append sunburn-default-colors-alist sunburn-override-colors-alist))

(defmacro sunburn-with-color-variables (&rest body)
  "`let' bind all colors defined in `sunburn-colors-alist' around BODY.
Also bind `class' to ((class color) (min-colors 89))."
  (declare (indent 0))
  `(let ((class '((class color) (min-colors 89)))
         ,@(mapcar (lambda (cons)
                     (list (intern (car cons)) (cdr cons)))
                   sunburn-colors-alist))
     ,@body))

;;; Theme Faces
(sunburn-with-color-variables
  (custom-theme-set-faces
   'sunburn
;;;; Built-in
;;;;; basic coloring
   `(button ((t (:foreground ,sunburn-yellow-2 :underline t))))
   `(widget-button ((t (:foreground ,sunburn-yellow-2 :underline t))))
   `(link ((t (:foreground ,sunburn-yellow :underline t :weight bold))))
   `(link-visited ((t (:foreground ,sunburn-yellow-2 :underline t :weight normal))))
   `(default ((t (:foreground ,sunburn-fg :background ,sunburn-bg))))
   `(cursor ((t (:foreground ,sunburn-fg :background ,sunburn-fg+1))))
   `(escape-glyph ((t (:foreground ,sunburn-yellow :weight bold))))
   `(fringe ((t (:foreground ,sunburn-fg :background ,sunburn-bg+1))))
   `(header-line ((t (:foreground ,sunburn-yellow
                                  :background ,sunburn-bg-1
                                  :box (:line-width -1 :style released-button)))))
   `(highlight ((t (:background ,sunburn-bg-05))))
   `(success ((t (:foreground ,sunburn-green :weight bold))))
   `(warning ((t (:foreground ,sunburn-orange :weight bold))))
   `(tooltip ((t (:foreground ,sunburn-fg :background ,sunburn-bg+1))))


   ;; Spaceline colors

   `(spaceline-evil-insert ((t (:foreground ,sunburn-green :weight bold))))
;;;;; compilation
   `(compilation-column-face ((t (:foreground ,sunburn-yellow))))
   `(compilation-enter-directory-face ((t (:foreground ,sunburn-green))))
   `(compilation-error-face ((t (:foreground ,sunburn-red-1 :weight bold :underline t))))
   `(compilation-face ((t (:foreground ,sunburn-fg))))
   `(compilation-info-face ((t (:foreground ,sunburn-blue))))
   `(compilation-info ((t (:foreground ,sunburn-green+4 :underline t))))
   `(compilation-leave-directory-face ((t (:foreground ,sunburn-green))))
   `(compilation-line-face ((t (:foreground ,sunburn-yellow))))
   `(compilation-line-number ((t (:foreground ,sunburn-yellow))))
   `(compilation-message-face ((t (:foreground ,sunburn-blue))))
   `(compilation-warning-face ((t (:foreground ,sunburn-orange :weight bold :underline t))))
   `(compilation-mode-line-exit ((t (:foreground ,sunburn-green+2 :weight bold))))
   `(compilation-mode-line-fail ((t (:foreground ,sunburn-red :weight bold))))
   `(compilation-mode-line-run ((t (:foreground ,sunburn-yellow :weight bold))))
;;;;; completions
   `(completions-annotations ((t (:foreground ,sunburn-fg-1))))
;;;;; grep
   `(grep-context-face ((t (:foreground ,sunburn-fg))))
   `(grep-error-face ((t (:foreground ,sunburn-red-1 :weight bold :underline t))))
   `(grep-hit-face ((t (:foreground ,sunburn-blue))))
   `(grep-match-face ((t (:foreground ,sunburn-orange :weight bold))))
   `(match ((t (:background ,sunburn-bg-1 :foreground ,sunburn-orange :weight bold))))
;;;;; info
   `(Info-quoted ((t (:inherit font-lock-constant-face))))
;;;;; isearch
   `(isearch ((t (:foreground ,sunburn-yellow-2 :weight bold :background ,sunburn-bg+2))))
   `(isearch-fail ((t (:foreground ,sunburn-fg :background ,sunburn-red-4))))
   `(lazy-highlight ((t (:foreground ,sunburn-yellow-2 :weight bold :background ,sunburn-bg-05))))

   `(menu ((t (:foreground ,sunburn-fg :background ,sunburn-bg))))
   `(minibuffer-prompt ((t (:background ,sunburn-bg-05 :foreground ,sunburn-yellow))))
   `(mode-line
     ((,class (:foreground ,sunburn-fg+1
                           :background ,sunburn-bg-05
                           :box (:line-width -1 :style released-button)))
      (t :inverse-video t)))
   `(mode-line-buffer-id ((t (:foreground ,sunburn-fg-1 :weight bold))))
   `(mode-line-inactive
     ((t (:foreground ,sunburn-blue-1
                      :background ,sunburn-bg-05
                      :box (:line-width -1 :style released-button)))))
   ;; `(region ((,class (:background ,sunburn-gold))
   ;;           (t :inverse-video t)))
   `(region ((t (:foreground ,sunburn-bg-05  :background ,sunburn-gold :reverse-video t))))
   `(secondary-selection ((t (:background ,sunburn-bg+2))))
   `(trailing-whitespace ((t (:background ,sunburn-red))))
   `(vertical-border ((t (:foreground ,sunburn-fg))))
;;;;; font lock
   `(font-lock-builtin-face ((t (:foreground ,sunburn-fg-1, :weight bold))))
   `(font-lock-comment-face ((t (:background ,sunburn-bg :foreground ,sunburn-bg+3))))
   `(font-lock-comment-delimiter-face ((t (:background ,sunburn-bg :foreground ,sunburn-bg+3))))
   `(font-lock-constant-face ((t (:foreground ,sunburn-blue+1))))
   `(font-lock-doc-face ((t (:foreground ,sunburn-blue+1))))
   `(font-lock-function-name-face ((t (:foreground ,sunburn-cyan))))
   `(font-lock-keyword-face ((t (:foreground ,sunburn-yellow :weight bold))))
   `(font-lock-negation-char-face ((t (:foreground ,sunburn-yellow :weight bold))))
   `(font-lock-preprocessor-face ((t (:foreground ,sunburn-blue+1))))
   `(font-lock-regexp-grouping-construct ((t (:foreground ,sunburn-yellow :weight bold))))
   `(font-lock-regexp-grouping-backslash ((t (:foreground ,sunburn-green :weight bold))))
   `(font-lock-string-face ((t (:foreground ,sunburn-red+1))))
   `(font-lock-type-face ((t (:foreground ,sunburn-green))))
   `(font-lock-variable-name-face ((t (:foreground ,sunburn-yellow-1))))
   `(font-lock-warning-face ((t (:foreground ,sunburn-yellow-2 :weight bold))))

   `(c-annotation-face ((t (:inherit font-lock-constant-face))))
;;;;; newsticker
   `(newsticker-date-face ((t (:foreground ,sunburn-fg))))
   `(newsticker-default-face ((t (:foreground ,sunburn-fg))))
   `(newsticker-enclosure-face ((t (:foreground ,sunburn-green+3))))
   `(newsticker-extra-face ((t (:foreground ,sunburn-bg+2 :height 0.8))))
   `(newsticker-feed-face ((t (:foreground ,sunburn-fg))))
   `(newsticker-immortal-item-face ((t (:foreground ,sunburn-green))))
   `(newsticker-new-item-face ((t (:foreground ,sunburn-blue))))
   `(newsticker-obsolete-item-face ((t (:foreground ,sunburn-red))))
   `(newsticker-old-item-face ((t (:foreground ,sunburn-bg+3))))
   `(newsticker-statistics-face ((t (:foreground ,sunburn-fg))))
   `(newsticker-treeview-face ((t (:foreground ,sunburn-fg))))
   `(newsticker-treeview-immortal-face ((t (:foreground ,sunburn-green))))
   `(newsticker-treeview-listwindow-face ((t (:foreground ,sunburn-fg))))
   `(newsticker-treeview-new-face ((t (:foreground ,sunburn-blue :weight bold))))
   `(newsticker-treeview-obsolete-face ((t (:foreground ,sunburn-red))))
   `(newsticker-treeview-old-face ((t (:foreground ,sunburn-bg+3))))
   `(newsticker-treeview-selection-face ((t (:background ,sunburn-bg-1 :foreground ,sunburn-yellow))))
;;;; Third-party
;;;;; ace-jump
   `(ace-jump-face-background
     ((t (:foreground ,sunburn-fg-1 :background ,sunburn-bg :inverse-video nil))))
   `(ace-jump-face-foreground
     ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg :inverse-video nil))))
;;;;; ace-window
   `(aw-background-face
     ((t (:foreground ,sunburn-fg-1 :background ,sunburn-bg :inverse-video nil))))
   `(aw-leading-char-face ((t (:inherit aw-mode-line-face))))
;;;;; android mode
   `(android-mode-debug-face ((t (:foreground ,sunburn-green+1))))
   `(android-mode-error-face ((t (:foreground ,sunburn-orange :weight bold))))
   `(android-mode-info-face ((t (:foreground ,sunburn-fg))))
   `(android-mode-verbose-face ((t (:foreground ,sunburn-green))))
   `(android-mode-warning-face ((t (:foreground ,sunburn-yellow))))
;;;;; anzu
   `(anzu-mode-line ((t (:foreground ,sunburn-cyan :weight bold))))
   `(anzu-mode-line-no-match ((t (:foreground ,sunburn-red :weight bold))))
   `(anzu-match-1 ((t (:foreground ,sunburn-bg :background ,sunburn-green))))
   `(anzu-match-2 ((t (:foreground ,sunburn-bg :background ,sunburn-orange))))
   `(anzu-match-3 ((t (:foreground ,sunburn-bg :background ,sunburn-blue))))
   `(anzu-replace-to ((t (:inherit anzu-replace-highlight :foreground ,sunburn-yellow))))
;;;;; auctex
   `(font-latex-bold-face ((t (:inherit bold))))
   `(font-latex-warning-face ((t (:foreground nil :inherit font-lock-warning-face))))
   `(font-latex-slide-title-face ((t (:foreground ,sunburn-cyan :weight bold :scale 1.3))))
   `(font-latex-sectioning-0-face ((t (:foreground ,sunburn-yellow :weight bold :scale 1.3))))
   `(font-latex-sectioning-1-face ((t (:foreground ,sunburn-blue+1 :weight bold :scale 1.2))))
   `(font-latex-sectioning-2-face ((t (:foreground ,sunburn-orange :weight bold :scale 1.1))))
   `(font-latex-sectioning-3-face ((t (:foreground ,sunburn-cyan :weight bold ))))
   `(font-latex-sectioning-4-face ((t (:foreground ,sunburn-green :weight bold ))))
   `(font-latex-sectioning-5-face ((t (:foreground ,sunburn-red :weight bold ))))
   `(font-latex-verbatim-face ((t (:foreground ,sunburn-blue+1 :weight bold ))))
   `(font-latex-sedate-face ((t (:foreground ,sunburn-yellow))))
   `(font-latex-italic-face ((t (:foreground ,sunburn-cyan :slant italic))))
   `(font-latex-string-face ((t (:foreground ,sunburn-red+1))))
   `(font-latex-math-face ((t (:foreground ,sunburn-orange))))
;;;;; agda-mode
   `(agda2-highlight-keyword-face ((t (:foreground ,sunburn-yellow :weight bold))))
   `(agda2-highlight-string-face ((t (:foreground ,sunburn-red))))
   `(agda2-highlight-symbol-face ((t (:foreground ,sunburn-orange))))
   `(agda2-highlight-primitive-type-face ((t (:foreground ,sunburn-blue-1))))
   `(agda2-highlight-inductive-constructor-face ((t (:foreground ,sunburn-fg))))
   `(agda2-highlight-coinductive-constructor-face ((t (:foreground ,sunburn-fg))))
   `(agda2-highlight-datatype-face ((t (:foreground ,sunburn-blue))))
   `(agda2-highlight-function-face ((t (:foreground ,sunburn-blue))))
   `(agda2-highlight-module-face ((t (:foreground ,sunburn-blue-1))))
   `(agda2-highlight-error-face ((t (:foreground ,sunburn-bg :background ,sunburn-magenta))))
   `(agda2-highlight-unsolved-meta-face ((t (:foreground ,sunburn-bg :background ,sunburn-magenta))))
   `(agda2-highlight-unsolved-constraint-face ((t (:foreground ,sunburn-bg :background ,sunburn-magenta))))
   `(agda2-highlight-termination-problem-face ((t (:foreground ,sunburn-bg :background ,sunburn-magenta))))
   `(agda2-highlight-incomplete-pattern-face ((t (:foreground ,sunburn-bg :background ,sunburn-magenta))))
   `(agda2-highlight-typechecks-face ((t (:background ,sunburn-red-4))))
;;;;; auto-complete
   `(ac-candidate-face ((t (:background ,sunburn-bg+3 :foreground ,sunburn-bg-2))))
   `(ac-selection-face ((t (:background ,sunburn-blue-4 :foreground ,sunburn-fg))))
   `(popup-tip-face ((t (:background ,sunburn-yellow-2 :foreground ,sunburn-bg-2))))
   `(popup-menu-mouse-face ((t (:background ,sunburn-yellow-2 :foreground ,sunburn-bg-2))))
   `(popup-summary-face ((t (:background ,sunburn-bg+3 :foreground ,sunburn-bg-2))))
   `(popup-scroll-bar-foreground-face ((t (:background ,sunburn-blue-5))))
   `(popup-scroll-bar-background-face ((t (:background ,sunburn-bg-1))))
   `(popup-isearch-match ((t (:background ,sunburn-bg :foreground ,sunburn-fg))))
;;;;; avy
   `(avy-background-face
     ((t (:foreground ,sunburn-fg-1 :background ,sunburn-bg :inverse-video nil))))
   `(avy-lead-face-0
     ((t (:foreground ,sunburn-green+3 :background ,sunburn-bg :inverse-video nil :weight bold))))
   `(avy-lead-face-1
     ((t (:foreground ,sunburn-yellow :background ,sunburn-bg :inverse-video nil :weight bold))))
   `(avy-lead-face-2
     ((t (:foreground ,sunburn-red+1 :background ,sunburn-bg :inverse-video nil :weight bold))))
   `(avy-lead-face
     ((t (:foreground ,sunburn-cyan :background ,sunburn-bg :inverse-video nil :weight bold))))
;;;;; company-mode
   `(company-tooltip ((t (:foreground ,sunburn-fg :background ,sunburn-bg+1))))
   `(company-tooltip-annotation ((t (:foreground ,sunburn-orange :background ,sunburn-bg+1))))
   `(company-tooltip-annotation-selection ((t (:foreground ,sunburn-orange :background ,sunburn-bg-1))))
   `(company-tooltip-selection ((t (:foreground ,sunburn-fg :background ,sunburn-bg-1))))
   `(company-tooltip-mouse ((t (:background ,sunburn-bg-1))))
   `(company-tooltip-common ((t (:foreground ,sunburn-green+2))))
   `(company-tooltip-common-selection ((t (:foreground ,sunburn-green+2))))
   `(company-scrollbar-fg ((t (:background ,sunburn-bg-1))))
   `(company-scrollbar-bg ((t (:background ,sunburn-bg+2))))
   `(company-preview ((t (:background ,sunburn-green+2))))
   `(company-preview-common ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg-1))))
;;;;; bm
   `(bm-face ((t (:background ,sunburn-yellow-1 :foreground ,sunburn-bg))))
   `(bm-fringe-face ((t (:background ,sunburn-yellow-1 :foreground ,sunburn-bg))))
   `(bm-fringe-persistent-face ((t (:background ,sunburn-green-1 :foreground ,sunburn-bg))))
   `(bm-persistent-face ((t (:background ,sunburn-green-1 :foreground ,sunburn-bg))))
;;;;; calfw
   `(cfw:face-annotation ((t (:foreground ,sunburn-red :inherit cfw:face-day-title))))
   `(cfw:face-day-title ((t nil)))
   `(cfw:face-default-content ((t (:foreground ,sunburn-green))))
   `(cfw:face-default-day ((t (:weight bold))))
   `(cfw:face-disable ((t (:foreground ,sunburn-fg-1))))
   `(cfw:face-grid ((t (:inherit shadow))))
   `(cfw:face-header ((t (:inherit font-lock-keyword-face))))
   `(cfw:face-holiday ((t (:inherit cfw:face-sunday))))
   `(cfw:face-periods ((t (:foreground ,sunburn-cyan))))
   `(cfw:face-saturday ((t (:foreground ,sunburn-blue :weight bold))))
   `(cfw:face-select ((t (:background ,sunburn-blue-5))))
   `(cfw:face-sunday ((t (:foreground ,sunburn-red :weight bold))))
   `(cfw:face-title ((t (:height 2.0 :inherit (variable-pitch font-lock-keyword-face)))))
   `(cfw:face-today ((t (:foreground ,sunburn-cyan :weight bold))))
   `(cfw:face-today-title ((t (:inherit highlight bold))))
   `(cfw:face-toolbar ((t (:background ,sunburn-blue-5))))
   `(cfw:face-toolbar-button-off ((t (:underline nil :inherit link))))
   `(cfw:face-toolbar-button-on ((t (:underline nil :inherit link-visited))))
;;;;; cider
   `(cider-result-overlay-face ((t (:background unspecified))))
   `(cider-enlightened-face ((t (:box (:color ,sunburn-orange :line-width -1)))))
   `(cider-enlightened-local-face ((t (:weight bold :foreground ,sunburn-green+1))))
   `(cider-deprecated-face ((t (:background ,sunburn-yellow-2))))
   `(cider-instrumented-face ((t (:box (:color ,sunburn-red :line-width -1)))))
   `(cider-traced-face ((t (:box (:color ,sunburn-cyan :line-width -1)))))
   `(cider-test-failure-face ((t (:background ,sunburn-red-4))))
   `(cider-test-error-face ((t (:background ,sunburn-magenta))))
   `(cider-test-success-face ((t (:background ,sunburn-green-1))))
;;;;; circe
   `(circe-highlight-nick-face ((t (:foreground ,sunburn-cyan))))
   `(circe-my-message-face ((t (:foreground ,sunburn-fg))))
   `(circe-fool-face ((t (:foreground ,sunburn-red+1))))
   `(circe-topic-diff-removed-face ((t (:foreground ,sunburn-red :weight bold))))
   `(circe-originator-face ((t (:foreground ,sunburn-fg))))
   `(circe-server-face ((t (:foreground ,sunburn-green))))
   `(circe-topic-diff-new-face ((t (:foreground ,sunburn-orange :weight bold))))
   `(circe-prompt-face ((t (:foreground ,sunburn-orange :background ,sunburn-bg :weight bold))))
;;;;; context-coloring
   `(context-coloring-level-0-face ((t :foreground ,sunburn-fg)))
   `(context-coloring-level-1-face ((t :foreground ,sunburn-cyan)))
   `(context-coloring-level-2-face ((t :foreground ,sunburn-green+4)))
   `(context-coloring-level-3-face ((t :foreground ,sunburn-yellow)))
   `(context-coloring-level-4-face ((t :foreground ,sunburn-orange)))
   `(context-coloring-level-5-face ((t :foreground ,sunburn-magenta)))
   `(context-coloring-level-6-face ((t :foreground ,sunburn-blue+1)))
   `(context-coloring-level-7-face ((t :foreground ,sunburn-green+2)))
   `(context-coloring-level-8-face ((t :foreground ,sunburn-yellow-2)))
   `(context-coloring-level-9-face ((t :foreground ,sunburn-red+1)))
;;;;; coq
   `(coq-solve-tactics-face ((t (:foreground nil :inherit font-lock-constant-face))))
;;;;; ctable
   `(ctbl:face-cell-select ((t (:background ,sunburn-blue :foreground ,sunburn-bg))))
   `(ctbl:face-continue-bar ((t (:background ,sunburn-bg-05 :foreground ,sunburn-bg))))
   `(ctbl:face-row-select ((t (:background ,sunburn-cyan :foreground ,sunburn-bg))))
;;;;; debbugs
   `(debbugs-gnu-done ((t (:foreground ,sunburn-fg-1))))
   `(debbugs-gnu-handled ((t (:foreground ,sunburn-green))))
   `(debbugs-gnu-new ((t (:foreground ,sunburn-red))))
   `(debbugs-gnu-pending ((t (:foreground ,sunburn-blue))))
   `(debbugs-gnu-stale ((t (:foreground ,sunburn-orange))))
   `(debbugs-gnu-tagged ((t (:foreground ,sunburn-red))))
;;;;; diff
   `(diff-added          ((t (:background "#335533" :foreground ,sunburn-green))))
   `(diff-changed        ((t (:background "#555511" :foreground ,sunburn-yellow-1))))
   `(diff-removed        ((t (:background "#553333" :foreground ,sunburn-red-2))))
   `(diff-refine-added   ((t (:background "#338833" :foreground ,sunburn-green+4))))
   `(diff-refine-change  ((t (:background "#888811" :foreground ,sunburn-yellow))))
   `(diff-refine-removed ((t (:background "#883333" :foreground ,sunburn-red))))
   `(diff-header ((,class (:background ,sunburn-bg+2))
                  (t (:background ,sunburn-fg :foreground ,sunburn-bg))))
   `(diff-file-header
     ((,class (:background ,sunburn-bg+2 :foreground ,sunburn-fg :weight bold))
      (t (:background ,sunburn-fg :foreground ,sunburn-bg :weight bold))))
;;;;; diff-hl
   `(diff-hl-change ((,class (:foreground ,sunburn-blue :background ,sunburn-blue-2))))
   `(diff-hl-delete ((,class (:foreground ,sunburn-red+1 :background ,sunburn-red-1))))
   `(diff-hl-insert ((,class (:foreground ,sunburn-green+1 :background ,sunburn-green-1))))
;;;;; dim-autoload
   `(dim-autoload-cookie-line ((t :foreground ,sunburn-bg+1)))
;;;;; dired+
   `(diredp-display-msg ((t (:foreground ,sunburn-blue))))
   `(diredp-compressed-file-suffix ((t (:foreground ,sunburn-orange))))
   `(diredp-date-time ((t (:foreground ,sunburn-magenta))))
   `(diredp-deletion ((t (:foreground ,sunburn-yellow))))
   `(diredp-deletion-file-name ((t (:foreground ,sunburn-red))))
   `(diredp-dir-heading ((t (:foreground ,sunburn-blue :background ,sunburn-bg-1))))
   `(diredp-dir-priv ((t (:foreground ,sunburn-cyan))))
   `(diredp-exec-priv ((t (:foreground ,sunburn-red))))
   `(diredp-executable-tag ((t (:foreground ,sunburn-green+1))))
   `(diredp-file-name ((t (:foreground ,sunburn-blue))))
   `(diredp-file-suffix ((t (:foreground ,sunburn-green))))
   `(diredp-flag-mark ((t (:foreground ,sunburn-yellow))))
   `(diredp-flag-mark-line ((t (:foreground ,sunburn-orange))))
   `(diredp-ignored-file-name ((t (:foreground ,sunburn-red))))
   `(diredp-link-priv ((t (:foreground ,sunburn-yellow))))
   `(diredp-mode-line-flagged ((t (:foreground ,sunburn-yellow))))
   `(diredp-mode-line-marked ((t (:foreground ,sunburn-orange))))
   `(diredp-no-priv ((t (:foreground ,sunburn-fg))))
   `(diredp-number ((t (:foreground ,sunburn-green+1))))
   `(diredp-other-priv ((t (:foreground ,sunburn-yellow-1))))
   `(diredp-rare-priv ((t (:foreground ,sunburn-red-1))))
   `(diredp-read-priv ((t (:foreground ,sunburn-green-1))))
   `(diredp-symlink ((t (:foreground ,sunburn-yellow))))
   `(diredp-write-priv ((t (:foreground ,sunburn-magenta))))
;;;;; dired-async
   `(dired-async-failures ((t (:foreground ,sunburn-red :weight bold))))
   `(dired-async-message ((t (:foreground ,sunburn-yellow :weight bold))))
   `(dired-async-mode-message ((t (:foreground ,sunburn-yellow))))
;;;;; ediff
   `(ediff-current-diff-A ((t (:foreground ,sunburn-fg :background ,sunburn-red-4))))
   `(ediff-current-diff-Ancestor ((t (:foreground ,sunburn-fg :background ,sunburn-red-4))))
   `(ediff-current-diff-B ((t (:foreground ,sunburn-fg :background ,sunburn-green-1))))
   `(ediff-current-diff-C ((t (:foreground ,sunburn-fg :background ,sunburn-blue-5))))
   `(ediff-even-diff-A ((t (:background ,sunburn-bg+1))))
   `(ediff-even-diff-Ancestor ((t (:background ,sunburn-bg+1))))
   `(ediff-even-diff-B ((t (:background ,sunburn-bg+1))))
   `(ediff-even-diff-C ((t (:background ,sunburn-bg+1))))
   `(ediff-fine-diff-A ((t (:foreground ,sunburn-fg :background ,sunburn-red-2 :weight bold))))
   `(ediff-fine-diff-Ancestor ((t (:foreground ,sunburn-fg :background ,sunburn-red-2 weight bold))))
   `(ediff-fine-diff-B ((t (:foreground ,sunburn-fg :background ,sunburn-green :weight bold))))
   `(ediff-fine-diff-C ((t (:foreground ,sunburn-fg :background ,sunburn-blue-3 :weight bold ))))
   `(ediff-odd-diff-A ((t (:background ,sunburn-bg+2))))
   `(ediff-odd-diff-Ancestor ((t (:background ,sunburn-bg+2))))
   `(ediff-odd-diff-B ((t (:background ,sunburn-bg+2))))
   `(ediff-odd-diff-C ((t (:background ,sunburn-bg+2))))
;;;;; egg
   `(egg-text-base ((t (:foreground ,sunburn-fg))))
   `(egg-help-header-1 ((t (:foreground ,sunburn-yellow))))
   `(egg-help-header-2 ((t (:foreground ,sunburn-green+3))))
   `(egg-branch ((t (:foreground ,sunburn-yellow))))
   `(egg-branch-mono ((t (:foreground ,sunburn-yellow))))
   `(egg-term ((t (:foreground ,sunburn-yellow))))
   `(egg-diff-add ((t (:foreground ,sunburn-green+4))))
   `(egg-diff-del ((t (:foreground ,sunburn-red+1))))
   `(egg-diff-file-header ((t (:foreground ,sunburn-yellow-2))))
   `(egg-section-title ((t (:foreground ,sunburn-yellow))))
   `(egg-stash-mono ((t (:foreground ,sunburn-green+4))))
;;;;; elfeed
   `(elfeed-log-error-level-face ((t (:foreground ,sunburn-red))))
   `(elfeed-log-info-level-face ((t (:foreground ,sunburn-blue))))
   `(elfeed-log-warn-level-face ((t (:foreground ,sunburn-yellow))))
   `(elfeed-search-date-face ((t (:foreground ,sunburn-yellow-1 :underline t
                                              :weight bold))))
   `(elfeed-search-tag-face ((t (:foreground ,sunburn-green))))
   `(elfeed-search-feed-face ((t (:foreground ,sunburn-cyan))))
;;;;; emacs-w3m
   `(w3m-anchor ((t (:foreground ,sunburn-yellow :underline t
                                 :weight bold))))
   `(w3m-arrived-anchor ((t (:foreground ,sunburn-yellow-2
                                         :underline t :weight normal))))
   `(w3m-form ((t (:foreground ,sunburn-red-1 :underline t))))
   `(w3m-header-line-location-title ((t (:foreground ,sunburn-yellow
                                                     :underline t :weight bold))))
   '(w3m-history-current-url ((t (:inherit match))))
   `(w3m-lnum ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg))))
   `(w3m-lnum-match ((t (:background ,sunburn-bg-1
                                     :foreground ,sunburn-orange
                                     :weight bold))))
   `(w3m-lnum-minibuffer-prompt ((t (:foreground ,sunburn-yellow))))
;;;;; erc
   `(erc-action-face ((t (:inherit erc-default-face))))
   `(erc-bold-face ((t (:weight bold))))
   `(erc-current-nick-face ((t (:foreground ,sunburn-blue :weight bold))))
   `(erc-dangerous-host-face ((t (:inherit font-lock-warning-face))))
   `(erc-default-face ((t (:foreground ,sunburn-fg))))
   `(erc-direct-msg-face ((t (:inherit erc-default-face))))
   `(erc-error-face ((t (:inherit font-lock-warning-face))))
   `(erc-fool-face ((t (:inherit erc-default-face))))
   `(erc-highlight-face ((t (:inherit hover-highlight))))
   `(erc-input-face ((t (:foreground ,sunburn-yellow))))
   `(erc-keyword-face ((t (:foreground ,sunburn-blue :weight bold))))
   `(erc-nick-default-face ((t (:foreground ,sunburn-yellow :weight bold))))
   `(erc-my-nick-face ((t (:foreground ,sunburn-red :weight bold))))
   `(erc-nick-msg-face ((t (:inherit erc-default-face))))
   `(erc-notice-face ((t (:foreground ,sunburn-green))))
   `(erc-pal-face ((t (:foreground ,sunburn-orange :weight bold))))
   `(erc-prompt-face ((t (:foreground ,sunburn-orange :background ,sunburn-bg :weight bold))))
   `(erc-timestamp-face ((t (:foreground ,sunburn-green+4))))
   `(erc-underline-face ((t (:underline t))))
;;;;; eros
   `(eros-result-overlay-face ((t (:background unspecified))))
;;;;; ert
   `(ert-test-result-expected ((t (:foreground ,sunburn-green+4 :background ,sunburn-bg))))
   `(ert-test-result-unexpected ((t (:foreground ,sunburn-red :background ,sunburn-bg))))
;;;;; eshell
   `(eshell-prompt ((t (:foreground ,sunburn-yellow :weight bold))))
   `(eshell-ls-archive ((t (:foreground ,sunburn-red-1 :weight bold))))
   `(eshell-ls-backup ((t (:inherit font-lock-comment-face))))
   `(eshell-ls-clutter ((t (:inherit font-lock-comment-face))))
   `(eshell-ls-directory ((t (:foreground ,sunburn-blue+1 :weight bold))))
   `(eshell-ls-executable ((t (:foreground ,sunburn-red+1 :weight bold))))
   `(eshell-ls-unreadable ((t (:foreground ,sunburn-fg))))
   `(eshell-ls-missing ((t (:inherit font-lock-warning-face))))
   `(eshell-ls-product ((t (:inherit font-lock-doc-face))))
   `(eshell-ls-special ((t (:foreground ,sunburn-yellow :weight bold))))
   `(eshell-ls-symlink ((t (:foreground ,sunburn-cyan :weight bold))))
;;;;; flx
   `(flx-highlight-face ((t (:foreground ,sunburn-green+2 :weight bold))))
;;;;; flycheck
   `(flycheck-error
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-red-1) :inherit unspecified))
      (t (:foreground ,sunburn-red-1 :weight bold :underline t))))
   `(flycheck-warning
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-yellow) :inherit unspecified))
      (t (:foreground ,sunburn-yellow :weight bold :underline t))))
   `(flycheck-info
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-cyan) :inherit unspecified))
      (t (:foreground ,sunburn-cyan :weight bold :underline t))))
   `(flycheck-fringe-error ((t (:foreground ,sunburn-red-1 :weight bold))))
   `(flycheck-fringe-warning ((t (:foreground ,sunburn-yellow :weight bold))))
   `(flycheck-fringe-info ((t (:foreground ,sunburn-cyan :weight bold))))
;;;;; flymake
   `(flymake-errline
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-red)
                   :inherit unspecified :foreground unspecified :background unspecified))
      (t (:foreground ,sunburn-red-1 :weight bold :underline t))))
   `(flymake-warnline
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-orange)
                   :inherit unspecified :foreground unspecified :background unspecified))
      (t (:foreground ,sunburn-orange :weight bold :underline t))))
   `(flymake-infoline
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-green)
                   :inherit unspecified :foreground unspecified :background unspecified))
      (t (:foreground ,sunburn-green-1 :weight bold :underline t))))
;;;;; flyspell
   `(flyspell-duplicate
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-orange) :inherit unspecified))
      (t (:foreground ,sunburn-orange :weight bold :underline t))))
   `(flyspell-incorrect
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-red) :inherit unspecified))
      (t (:foreground ,sunburn-red-1 :weight bold :underline t))))
;;;;; full-ack
   `(ack-separator ((t (:foreground ,sunburn-fg))))
   `(ack-file ((t (:foreground ,sunburn-blue))))
   `(ack-line ((t (:foreground ,sunburn-yellow))))
   `(ack-match ((t (:foreground ,sunburn-orange :background ,sunburn-bg-1 :weight bold))))
;;;;; git-commit
   `(git-commit-comment-action  ((,class (:foreground ,sunburn-green+1 :weight bold))))
   `(git-commit-comment-branch  ((,class (:foreground ,sunburn-blue+1  :weight bold))))
   `(git-commit-comment-heading ((,class (:foreground ,sunburn-yellow  :weight bold))))
;;;;; git-gutter
   `(git-gutter:added ((t (:foreground ,sunburn-green :weight bold :inverse-video t))))
   `(git-gutter:deleted ((t (:foreground ,sunburn-red :weight bold :inverse-video t))))
   `(git-gutter:modified ((t (:foreground ,sunburn-magenta :weight bold :inverse-video t))))
   `(git-gutter:unchanged ((t (:foreground ,sunburn-fg :weight bold :inverse-video t))))
;;;;; git-gutter-fr
   `(git-gutter-fr:added ((t (:foreground ,sunburn-green  :weight bold))))
   `(git-gutter-fr:deleted ((t (:foreground ,sunburn-red :weight bold))))
   `(git-gutter-fr:modified ((t (:foreground ,sunburn-magenta :weight bold))))
;;;;; git-rebase
   `(git-rebase-hash ((t (:foreground, sunburn-orange))))
;;;;; gnus
   `(gnus-group-mail-1 ((t (:weight bold :inherit gnus-group-mail-1-empty))))
   `(gnus-group-mail-1-empty ((t (:inherit gnus-group-news-1-empty))))
   `(gnus-group-mail-2 ((t (:weight bold :inherit gnus-group-mail-2-empty))))
   `(gnus-group-mail-2-empty ((t (:inherit gnus-group-news-2-empty))))
   `(gnus-group-mail-3 ((t (:weight bold :inherit gnus-group-mail-3-empty))))
   `(gnus-group-mail-3-empty ((t (:inherit gnus-group-news-3-empty))))
   `(gnus-group-mail-4 ((t (:weight bold :inherit gnus-group-mail-4-empty))))
   `(gnus-group-mail-4-empty ((t (:inherit gnus-group-news-4-empty))))
   `(gnus-group-mail-5 ((t (:weight bold :inherit gnus-group-mail-5-empty))))
   `(gnus-group-mail-5-empty ((t (:inherit gnus-group-news-5-empty))))
   `(gnus-group-mail-6 ((t (:weight bold :inherit gnus-group-mail-6-empty))))
   `(gnus-group-mail-6-empty ((t (:inherit gnus-group-news-6-empty))))
   `(gnus-group-mail-low ((t (:weight bold :inherit gnus-group-mail-low-empty))))
   `(gnus-group-mail-low-empty ((t (:inherit gnus-group-news-low-empty))))
   `(gnus-group-news-1 ((t (:weight bold :inherit gnus-group-news-1-empty))))
   `(gnus-group-news-2 ((t (:weight bold :inherit gnus-group-news-2-empty))))
   `(gnus-group-news-3 ((t (:weight bold :inherit gnus-group-news-3-empty))))
   `(gnus-group-news-4 ((t (:weight bold :inherit gnus-group-news-4-empty))))
   `(gnus-group-news-5 ((t (:weight bold :inherit gnus-group-news-5-empty))))
   `(gnus-group-news-6 ((t (:weight bold :inherit gnus-group-news-6-empty))))
   `(gnus-group-news-low ((t (:weight bold :inherit gnus-group-news-low-empty))))
   `(gnus-header-content ((t (:inherit message-header-other))))
   `(gnus-header-from ((t (:inherit message-header-to))))
   `(gnus-header-name ((t (:inherit message-header-name))))
   `(gnus-header-newsgroups ((t (:inherit message-header-other))))
   `(gnus-header-subject ((t (:inherit message-header-subject))))
   `(gnus-server-opened ((t (:foreground ,sunburn-green+2 :weight bold))))
   `(gnus-server-denied ((t (:foreground ,sunburn-red+1 :weight bold))))
   `(gnus-server-closed ((t (:foreground ,sunburn-blue :slant italic))))
   `(gnus-server-offline ((t (:foreground ,sunburn-yellow :weight bold))))
   `(gnus-server-agent ((t (:foreground ,sunburn-blue :weight bold))))
   `(gnus-summary-cancelled ((t (:foreground ,sunburn-orange))))
   `(gnus-summary-high-ancient ((t (:foreground ,sunburn-blue))))
   `(gnus-summary-high-read ((t (:foreground ,sunburn-green :weight bold))))
   `(gnus-summary-high-ticked ((t (:foreground ,sunburn-orange :weight bold))))
   `(gnus-summary-high-unread ((t (:foreground ,sunburn-fg :weight bold))))
   `(gnus-summary-low-ancient ((t (:foreground ,sunburn-blue))))
   `(gnus-summary-low-read ((t (:foreground ,sunburn-green))))
   `(gnus-summary-low-ticked ((t (:foreground ,sunburn-orange :weight bold))))
   `(gnus-summary-low-unread ((t (:foreground ,sunburn-fg))))
   `(gnus-summary-normal-ancient ((t (:foreground ,sunburn-blue))))
   `(gnus-summary-normal-read ((t (:foreground ,sunburn-green))))
   `(gnus-summary-normal-ticked ((t (:foreground ,sunburn-orange :weight bold))))
   `(gnus-summary-normal-unread ((t (:foreground ,sunburn-fg))))
   `(gnus-summary-selected ((t (:foreground ,sunburn-yellow :weight bold))))
   `(gnus-cite-1 ((t (:foreground ,sunburn-blue))))
   `(gnus-cite-10 ((t (:foreground ,sunburn-yellow-1))))
   `(gnus-cite-11 ((t (:foreground ,sunburn-yellow))))
   `(gnus-cite-2 ((t (:foreground ,sunburn-blue-1))))
   `(gnus-cite-3 ((t (:foreground ,sunburn-blue-2))))
   `(gnus-cite-4 ((t (:foreground ,sunburn-green+2))))
   `(gnus-cite-5 ((t (:foreground ,sunburn-green+1))))
   `(gnus-cite-6 ((t (:foreground ,sunburn-green))))
   `(gnus-cite-7 ((t (:foreground ,sunburn-red))))
   `(gnus-cite-8 ((t (:foreground ,sunburn-red-1))))
   `(gnus-cite-9 ((t (:foreground ,sunburn-red-2))))
   `(gnus-group-news-1-empty ((t (:foreground ,sunburn-yellow))))
   `(gnus-group-news-2-empty ((t (:foreground ,sunburn-green+3))))
   `(gnus-group-news-3-empty ((t (:foreground ,sunburn-green+1))))
   `(gnus-group-news-4-empty ((t (:foreground ,sunburn-blue-2))))
   `(gnus-group-news-5-empty ((t (:foreground ,sunburn-blue-3))))
   `(gnus-group-news-6-empty ((t (:foreground ,sunburn-bg+2))))
   `(gnus-group-news-low-empty ((t (:foreground ,sunburn-bg+2))))
   `(gnus-signature ((t (:foreground ,sunburn-yellow))))
   `(gnus-x ((t (:background ,sunburn-fg :foreground ,sunburn-bg))))
;;;;; guide-key
   `(guide-key/highlight-command-face ((t (:foreground ,sunburn-blue))))
   `(guide-key/key-face ((t (:foreground ,sunburn-green))))
   `(guide-key/prefix-command-face ((t (:foreground ,sunburn-green+1))))
;;;;; helm
   `(helm-header
     ((t (:foreground ,sunburn-green
                      :background ,sunburn-bg
                      :underline nil
                      :box nil))))
   `(helm-source-header
     ((t (:foreground ,sunburn-yellow
                      :background ,sunburn-bg-1
                      :underline nil
                      :weight bold
                      :box (:line-width -1 :style released-button)))))
   `(helm-selection ((t (:background ,sunburn-bg-05 :foreground ,sunburn-gold :weight bold))))
   `(helm-selection-line ((t (:background ,sunburn-bg-05 :foreground ,sunburn-gold :weight bold))))
   `(helm-visible-mark ((t (:foreground ,sunburn-bg :background ,sunburn-yellow-2))))
   `(helm-candidate-number ((t (:foreground ,sunburn-green+4 :background ,sunburn-bg-1))))
   `(helm-separator ((t (:foreground ,sunburn-red :background ,sunburn-bg))))
   `(helm-time-zone-current ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg))))
   `(helm-time-zone-home ((t (:foreground ,sunburn-red :background ,sunburn-bg))))
   `(helm-bookmark-addressbook ((t (:foreground ,sunburn-orange :background ,sunburn-bg))))
   `(helm-bookmark-directory ((t (:foreground nil :background nil :inherit helm-ff-directory))))
   `(helm-bookmark-file ((t (:foreground nil :background nil :inherit helm-ff-file))))
   `(helm-bookmark-gnus ((t (:foreground ,sunburn-magenta :background ,sunburn-bg))))
   `(helm-bookmark-info ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg))))
   `(helm-bookmark-man ((t (:foreground ,sunburn-yellow :background ,sunburn-bg))))
   `(helm-bookmark-w3m ((t (:foreground ,sunburn-magenta :background ,sunburn-bg))))
   `(helm-buffer-not-saved ((t (:foreground ,sunburn-red :background ,sunburn-bg))))
   `(helm-buffer-process ((t (:foreground ,sunburn-cyan :background ,sunburn-bg))))
   `(helm-buffer-saved-out ((t (:foreground ,sunburn-fg :background ,sunburn-bg))))
   `(helm-buffer-size ((t (:foreground ,sunburn-fg-1 :background ,sunburn-bg))))
   `(helm-ff-directory ((t (:foreground ,sunburn-cyan :background ,sunburn-bg :weight bold))))
   `(helm-ff-file ((t (:foreground ,sunburn-fg :background ,sunburn-bg :weight normal))))
   `(helm-ff-executable ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg :weight normal))))
   `(helm-ff-invalid-symlink ((t (:foreground ,sunburn-red :background ,sunburn-bg :weight bold))))
   `(helm-ff-symlink ((t (:foreground ,sunburn-yellow :background ,sunburn-bg :weight bold))))
   `(helm-ff-prefix ((t (:foreground ,sunburn-bg :background ,sunburn-yellow :weight normal))))
   `(helm-grep-cmd-line ((t (:foreground ,sunburn-cyan :background ,sunburn-bg))))
   `(helm-grep-file ((t (:foreground ,sunburn-fg :background ,sunburn-bg))))
   `(helm-grep-finish ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg))))
   `(helm-grep-lineno ((t (:foreground ,sunburn-fg-1 :background ,sunburn-bg))))
   `(helm-grep-match ((t (:foreground nil :background nil :inherit helm-match))))
   `(helm-grep-running ((t (:foreground ,sunburn-red :background ,sunburn-bg))))
   `(helm-match ((t (:foreground ,sunburn-orange :background ,sunburn-bg-1 :weight bold))))
   `(helm-moccur-buffer ((t (:foreground ,sunburn-cyan :background ,sunburn-bg))))
   `(helm-mu-contacts-address-face ((t (:foreground ,sunburn-fg-1 :background ,sunburn-bg))))
   `(helm-mu-contacts-name-face ((t (:foreground ,sunburn-fg :background ,sunburn-bg))))
;;;;; helm-swoop
   `(helm-swoop-target-line-face ((t (:foreground ,sunburn-fg :background ,sunburn-bg+1))))
   `(helm-swoop-target-word-face ((t (:foreground ,sunburn-yellow :background ,sunburn-bg+2 :weight bold))))
;;;;; hl-line-mode
   `(hl-line-face ((,class (:background ,sunburn-bg-05))
                   (t :weight bold)))
   `(hl-line ((,class (:background ,sunburn-bg-05)) ; old emacsen
              (t :weight bold)))
;;;;; hl-sexp
   `(hl-sexp-face ((,class (:background ,sunburn-bg+1))
                   (t :weight bold)))
;;;;; hydra
   `(hydra-face-red ((t (:foreground ,sunburn-red-1 :background ,sunburn-bg))))
   `(hydra-face-amaranth ((t (:foreground ,sunburn-red-3 :background ,sunburn-bg))))
   `(hydra-face-blue ((t (:foreground ,sunburn-blue :background ,sunburn-bg))))
   `(hydra-face-pink ((t (:foreground ,sunburn-magenta :background ,sunburn-bg))))
   `(hydra-face-teal ((t (:foreground ,sunburn-cyan :background ,sunburn-bg))))
;;;;; irfc
   `(irfc-head-name-face ((t (:foreground ,sunburn-red :weight bold))))
   `(irfc-head-number-face ((t (:foreground ,sunburn-red :weight bold))))
   `(irfc-reference-face ((t (:foreground ,sunburn-blue-1 :weight bold))))
   `(irfc-requirement-keyword-face ((t (:inherit font-lock-keyword-face))))
   `(irfc-rfc-link-face ((t (:inherit link))))
   `(irfc-rfc-number-face ((t (:foreground ,sunburn-cyan :weight bold))))
   `(irfc-std-number-face ((t (:foreground ,sunburn-green+4 :weight bold))))
   `(irfc-table-item-face ((t (:foreground ,sunburn-green+3))))
   `(irfc-title-face ((t (:foreground ,sunburn-yellow
                                      :underline t :weight bold))))
;;;;; ivy
   `(ivy-confirm-face ((t (:foreground ,sunburn-green :background ,sunburn-bg))))
   `(ivy-match-required-face ((t (:foreground ,sunburn-red :background ,sunburn-bg))))
   `(ivy-remote ((t (:foreground ,sunburn-blue :background ,sunburn-bg))))
   `(ivy-subdir ((t (:foreground ,sunburn-yellow :background ,sunburn-bg))))
   `(ivy-current-match ((t (:foreground ,sunburn-yellow :weight bold :underline t))))
   `(ivy-minibuffer-match-face-1 ((t (:background ,sunburn-bg+1))))
   `(ivy-minibuffer-match-face-2 ((t (:background ,sunburn-green-1))))
   `(ivy-minibuffer-match-face-3 ((t (:background ,sunburn-green))))
   `(ivy-minibuffer-match-face-4 ((t (:background ,sunburn-green+1))))
;;;;; ido-mode
   `(ido-first-match ((t (:foreground ,sunburn-yellow :weight bold))))
   `(ido-only-match ((t (:foreground ,sunburn-orange :weight bold))))
   `(ido-subdir ((t (:foreground ,sunburn-yellow))))
   `(ido-indicator ((t (:foreground ,sunburn-yellow :background ,sunburn-red-4))))
;;;;; iedit-mode
   `(iedit-occurrence ((t (:background ,sunburn-bg+2 :weight bold))))
;;;;; jabber-mode
   `(jabber-roster-user-away ((t (:foreground ,sunburn-green+2))))
   `(jabber-roster-user-online ((t (:foreground ,sunburn-blue-1))))
   `(jabber-roster-user-dnd ((t (:foreground ,sunburn-red+1))))
   `(jabber-roster-user-xa ((t (:foreground ,sunburn-magenta))))
   `(jabber-roster-user-chatty ((t (:foreground ,sunburn-orange))))
   `(jabber-roster-user-error ((t (:foreground ,sunburn-red+1))))
   `(jabber-rare-time-face ((t (:foreground ,sunburn-green+1))))
   `(jabber-chat-prompt-local ((t (:foreground ,sunburn-blue-1))))
   `(jabber-chat-prompt-foreign ((t (:foreground ,sunburn-red+1))))
   `(jabber-chat-prompt-system ((t (:foreground ,sunburn-green+3))))
   `(jabber-activity-face((t (:foreground ,sunburn-red+1))))
   `(jabber-activity-personal-face ((t (:foreground ,sunburn-blue+1))))
   `(jabber-title-small ((t (:height 1.1 :weight bold))))
   `(jabber-title-medium ((t (:height 1.2 :weight bold))))
   `(jabber-title-large ((t (:height 1.3 :weight bold))))
;;;;; js2-mode
   `(js2-warning ((t (:underline ,sunburn-orange))))
   `(js2-error ((t (:foreground ,sunburn-red :weight bold))))
   `(js2-jsdoc-tag ((t (:foreground ,sunburn-green-1))))
   `(js2-jsdoc-type ((t (:foreground ,sunburn-green+2))))
   `(js2-jsdoc-value ((t (:foreground ,sunburn-green+3))))
   `(js2-function-param ((t (:foreground, sunburn-orange))))
   `(js2-external-variable ((t (:foreground ,sunburn-orange))))
;;;;; additional js2 mode attributes for better syntax highlighting
   `(js2-instance-member ((t (:foreground ,sunburn-green-1))))
   `(js2-jsdoc-html-tag-delimiter ((t (:foreground ,sunburn-orange))))
   `(js2-jsdoc-html-tag-name ((t (:foreground ,sunburn-red-1))))
   `(js2-object-property ((t (:foreground ,sunburn-blue+1))))
   `(js2-magic-paren ((t (:foreground ,sunburn-blue-5))))
   `(js2-private-function-call ((t (:foreground ,sunburn-cyan))))
   `(js2-function-call ((t (:foreground ,sunburn-cyan))))
   `(js2-private-member ((t (:foreground ,sunburn-blue-1))))
   `(js2-keywords ((t (:foreground ,sunburn-magenta))))
;;;;; ledger-mode
   `(ledger-font-payee-uncleared-face ((t (:foreground ,sunburn-red-1 :weight bold))))
   `(ledger-font-payee-cleared-face ((t (:foreground ,sunburn-fg :weight normal))))
   `(ledger-font-payee-pending-face ((t (:foreground ,sunburn-red :weight normal))))
   `(ledger-font-xact-highlight-face ((t (:background ,sunburn-bg+1))))
   `(ledger-font-auto-xact-face ((t (:foreground ,sunburn-yellow-1 :weight normal))))
   `(ledger-font-periodic-xact-face ((t (:foreground ,sunburn-green :weight normal))))
   `(ledger-font-pending-face ((t (:foreground ,sunburn-orange weight: normal))))
   `(ledger-font-other-face ((t (:foreground ,sunburn-fg))))
   `(ledger-font-posting-date-face ((t (:foreground ,sunburn-orange :weight normal))))
   `(ledger-font-posting-account-face ((t (:foreground ,sunburn-blue-1))))
   `(ledger-font-posting-account-cleared-face ((t (:foreground ,sunburn-fg))))
   `(ledger-font-posting-account-pending-face ((t (:foreground ,sunburn-orange))))
   `(ledger-font-posting-amount-face ((t (:foreground ,sunburn-orange))))
   `(ledger-occur-narrowed-face ((t (:foreground ,sunburn-fg-1 :invisible t))))
   `(ledger-occur-xact-face ((t (:background ,sunburn-bg+1))))
   `(ledger-font-comment-face ((t (:foreground ,sunburn-green))))
   `(ledger-font-reconciler-uncleared-face ((t (:foreground ,sunburn-red-1 :weight bold))))
   `(ledger-font-reconciler-cleared-face ((t (:foreground ,sunburn-fg :weight normal))))
   `(ledger-font-reconciler-pending-face ((t (:foreground ,sunburn-orange :weight normal))))
   `(ledger-font-report-clickable-face ((t (:foreground ,sunburn-orange :weight normal))))
;;;;; linum-mode
   `(linum ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg))))
;;;;; Line numbers in Emacs 26
   `(line-number ((t (:foreground ,sunburn-bg+3 :background ,sunburn-bg))))
   `(line-number-current-line ((t (:foreground ,sunburn-green+1 :background ,sunburn-bg))))
;;;;; lispy
   `(lispy-command-name-face ((t (:background ,sunburn-bg-05 :inherit font-lock-function-name-face))))
   `(lispy-cursor-face ((t (:foreground ,sunburn-bg :background ,sunburn-fg))))
   `(lispy-face-hint ((t (:inherit highlight :foreground ,sunburn-yellow))))
;;;;; ruler-mode
   `(ruler-mode-column-number ((t (:inherit 'ruler-mode-default :foreground ,sunburn-fg))))
   `(ruler-mode-fill-column ((t (:inherit 'ruler-mode-default :foreground ,sunburn-yellow))))
   `(ruler-mode-goal-column ((t (:inherit 'ruler-mode-fill-column))))
   `(ruler-mode-comment-column ((t (:inherit 'ruler-mode-fill-column))))
   `(ruler-mode-tab-stop ((t (:inherit 'ruler-mode-fill-column))))
   `(ruler-mode-current-column ((t (:foreground ,sunburn-yellow :box t))))
   `(ruler-mode-default ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg))))

;;;;; lui
   `(lui-time-stamp-face ((t (:foreground ,sunburn-blue-1))))
   `(lui-hilight-face ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg))))
   `(lui-button-face ((t (:inherit hover-highlight))))
;;;;; macrostep
   `(macrostep-gensym-1
     ((t (:foreground ,sunburn-green+2 :background ,sunburn-bg-1))))
   `(macrostep-gensym-2
     ((t (:foreground ,sunburn-red+1 :background ,sunburn-bg-1))))
   `(macrostep-gensym-3
     ((t (:foreground ,sunburn-blue+1 :background ,sunburn-bg-1))))
   `(macrostep-gensym-4
     ((t (:foreground ,sunburn-magenta :background ,sunburn-bg-1))))
   `(macrostep-gensym-5
     ((t (:foreground ,sunburn-yellow :background ,sunburn-bg-1))))
   `(macrostep-expansion-highlight-face
     ((t (:inherit highlight))))
   `(macrostep-macro-face
     ((t (:underline t))))
;;;;; magit
;;;;;; headings and diffs
   `(magit-section-highlight           ((t (:background ,sunburn-bg-1 :foreground ,sunburn-fg-1))))
   `(magit-section-heading             ((t (:foreground ,sunburn-yellow :weight bold))))
   `(magit-section-heading-selection   ((t (:foreground ,sunburn-orange :weight bold))))
   `(magit-diff-file-heading           ((t (:background ,sunburn-bg-05 :foreground ,sunburn-fg+1 :weight bold))))
   `(magit-diff-file-heading-highlight ((t (:background ,sunburn-bg-05  :weight bold))))
   `(magit-diff-file-heading-selection ((t (:background ,sunburn-bg-05
                                                        :foreground ,sunburn-gold :weight bold))))
   `(magit-diff-hunk-heading           ((t (:background ,sunburn-bg-05))))
   `(magit-diff-hunk-heading-highlight ((t (:background ,sunburn-bg-05 :foreground ,sunburn-gold))))
   `(magit-diff-hunk-heading-selection ((t (:background ,sunburn-bg+2
                                                        :foreground ,sunburn-orange))))
   `(magit-diff-lines-heading          ((t (:background ,sunburn-red+1
                                                        :foreground ,sunburn-bg-2))))
   `(magit-diff-base      ((t (:background ,sunburn-bg :foreground ,sunburn-fg))))
   `(magit-diff-context   ((t (:background ,sunburn-bg :foreground ,sunburn-fg :weight bold))))
   `(magit-diff-context-highlight ((t (:background ,sunburn-bg :foreground ,sunburn-gold))))
   `(magit-diff-removed-highlight ((t (:background ,sunburn-bg :foreground ,sunburn-red-2))))
   `(magit-diff-removed  ((t (:background ,sunburn-bg :foreground ,sunburn-red+1))))
   `(magit-diff-added-highlight  ((t (:background ,sunburn-bg :foreground ,sunburn-green+3))))
   `(magit-diff-added  ((t (:background ,sunburn-bg :foreground ,sunburn-green+4))))
   `(magit-diffstat-added   ((t (:background ,sunburn-bg :foreground ,sunburn-green+4))))
   `(magit-diff-whitespace-warning ((t (:background ,sunburn-red :foreground ,sunburn-fg+1))))
   `(magit-diff-conflict-heading ((t (:background ,sunburn-red-4 :foreground ,sunburn-fg+1))))
   `(magit-diffstat-removed ((t (:foreground ,sunburn-red))))
;;;;;; popup
   `(magit-popup-heading             ((t (:foreground ,sunburn-yellow  :weight bold))))
   `(magit-popup-key                 ((t (:foreground ,sunburn-green-1 :weight bold))))
   `(magit-popup-argument            ((t (:foreground ,sunburn-green   :weight bold))))
   `(magit-popup-disabled-argument   ((t (:foreground ,sunburn-fg-1    :weight normal))))
   `(magit-popup-option-value        ((t (:foreground ,sunburn-blue-2  :weight bold))))
;;;;;; process
   `(magit-process-ok    ((t (:foreground ,sunburn-green  :weight bold))))
   `(magit-process-ng    ((t (:foreground ,sunburn-red    :weight bold))))
;;;;;; log
   `(magit-log-author    ((t (:foreground ,sunburn-orange))))
   `(magit-log-date      ((t (:foreground ,sunburn-fg-1))))
   `(magit-log-graph     ((t (:foreground ,sunburn-fg+1))))
;;;;;; sequence
   `(magit-sequence-pick ((t (:foreground ,sunburn-yellow-2))))
   `(magit-sequence-stop ((t (:foreground ,sunburn-green))))
   `(magit-sequence-part ((t (:foreground ,sunburn-yellow))))
   `(magit-sequence-head ((t (:foreground ,sunburn-blue))))
   `(magit-sequence-drop ((t (:foreground ,sunburn-red))))
   `(magit-sequence-done ((t (:foreground ,sunburn-fg-1))))
   `(magit-sequence-onto ((t (:foreground ,sunburn-fg-1))))
;;;;;; bisect
   `(magit-bisect-good ((t (:background ,sunburn-bg :foreground ,sunburn-green))))
   `(magit-bisect-skip ((t (:background ,sunburn-bg :foreground ,sunburn-yellow))))
   `(magit-bisect-bad  ((t (:background ,sunburn-bg :foreground ,sunburn-red))))
;;;;;; blame
   `(magit-blame-heading ((t (:background ,sunburn-bg-1 :foreground ,sunburn-blue+1))))
   `(magit-blame-hash    ((t (:background ,sunburn-bg-1 :foreground ,sunburn-orange))))
   `(magit-blame-name    ((t (:background ,sunburn-bg-1 :foreground ,sunburn-orange))))
   `(magit-blame-date    ((t (:background ,sunburn-bg-1 :foreground ,sunburn-orange))))
   `(magit-blame-summary ((t (:background ,sunburn-bg-1 :foreground ,sunburn-blue-2
                                          :weight bold))))
;;;;;; references etc
   `(magit-dimmed         ((t (:background ,sunburn-bg :foreground ,sunburn-bg+3))))
   `(magit-hash           ((t (:background ,sunburn-bg :foreground ,sunburn-bg+3))))
   `(magit-tag            ((t (:background ,sunburn-bg :foreground ,sunburn-orange :weight bold))))
   `(magit-branch-remote  ((t (:background ,sunburn-bg :foreground ,sunburn-green  :weight bold))))
   `(magit-branch-local   ((t (:background ,sunburn-bg :foreground ,sunburn-blue   :weight bold))))
   `(magit-branch-current ((t (:background ,sunburn-bg :foreground ,sunburn-blue   :weight bold :box t))))
   `(magit-head           ((t (:background ,sunburn-bg :foreground ,sunburn-blue   :weight bold))))
   `(magit-refname        ((t (:background ,sunburn-bg+2 :foreground ,sunburn-fg :weight bold))))
   `(magit-refname-stash  ((t (:background ,sunburn-bg+2 :foreground ,sunburn-fg :weight bold))))
   `(magit-refname-wip    ((t (:background ,sunburn-bg+2 :foreground ,sunburn-fg :weight bold))))
   `(magit-signature-good      ((t (:foreground ,sunburn-green))))
   `(magit-signature-bad       ((t (:foreground ,sunburn-red))))
   `(magit-signature-untrusted ((t (:foreground ,sunburn-yellow))))
   `(magit-cherry-unmatched    ((t (:foreground ,sunburn-cyan))))
   `(magit-cherry-equivalent   ((t (:foreground ,sunburn-magenta))))
   `(magit-reflog-commit       ((t (:foreground ,sunburn-green))))
   `(magit-reflog-amend        ((t (:foreground ,sunburn-magenta))))
   `(magit-reflog-merge        ((t (:foreground ,sunburn-green))))
   `(magit-reflog-checkout     ((t (:foreground ,sunburn-blue))))
   `(magit-reflog-reset        ((t (:foreground ,sunburn-red))))
   `(magit-reflog-rebase       ((t (:foreground ,sunburn-magenta))))
   `(magit-reflog-cherry-pick  ((t (:foreground ,sunburn-green))))
   `(magit-reflog-remote       ((t (:foreground ,sunburn-cyan))))
   `(magit-reflog-other        ((t (:foreground ,sunburn-cyan))))
;;;;; message-mode
   `(message-cited-text ((t (:inherit font-lock-comment-face))))
   `(message-header-name ((t (:foreground ,sunburn-green+1))))
   `(message-header-other ((t (:foreground ,sunburn-green))))
   `(message-header-to ((t (:foreground ,sunburn-yellow :weight bold))))
   `(message-header-cc ((t (:foreground ,sunburn-yellow :weight bold))))
   `(message-header-newsgroups ((t (:foreground ,sunburn-yellow :weight bold))))
   `(message-header-subject ((t (:foreground ,sunburn-orange :weight bold))))
   `(message-header-xheader ((t (:foreground ,sunburn-green))))
   `(message-mml ((t (:foreground ,sunburn-yellow :weight bold))))
   `(message-separator ((t (:inherit font-lock-comment-face))))
;;;;; mew
   `(mew-face-header-subject ((t (:foreground ,sunburn-orange))))
   `(mew-face-header-from ((t (:foreground ,sunburn-yellow))))
   `(mew-face-header-date ((t (:foreground ,sunburn-green))))
   `(mew-face-header-to ((t (:foreground ,sunburn-red))))
   `(mew-face-header-key ((t (:foreground ,sunburn-green))))
   `(mew-face-header-private ((t (:foreground ,sunburn-green))))
   `(mew-face-header-important ((t (:foreground ,sunburn-blue))))
   `(mew-face-header-marginal ((t (:foreground ,sunburn-fg :weight bold))))
   `(mew-face-header-warning ((t (:foreground ,sunburn-red))))
   `(mew-face-header-xmew ((t (:foreground ,sunburn-green))))
   `(mew-face-header-xmew-bad ((t (:foreground ,sunburn-red))))
   `(mew-face-body-url ((t (:foreground ,sunburn-orange))))
   `(mew-face-body-comment ((t (:foreground ,sunburn-fg :slant italic))))
   `(mew-face-body-cite1 ((t (:foreground ,sunburn-green))))
   `(mew-face-body-cite2 ((t (:foreground ,sunburn-blue))))
   `(mew-face-body-cite3 ((t (:foreground ,sunburn-orange))))
   `(mew-face-body-cite4 ((t (:foreground ,sunburn-yellow))))
   `(mew-face-body-cite5 ((t (:foreground ,sunburn-red))))
   `(mew-face-mark-review ((t (:foreground ,sunburn-blue))))
   `(mew-face-mark-escape ((t (:foreground ,sunburn-green))))
   `(mew-face-mark-delete ((t (:foreground ,sunburn-red))))
   `(mew-face-mark-unlink ((t (:foreground ,sunburn-yellow))))
   `(mew-face-mark-refile ((t (:foreground ,sunburn-green))))
   `(mew-face-mark-unread ((t (:foreground ,sunburn-red-2))))
   `(mew-face-eof-message ((t (:foreground ,sunburn-green))))
   `(mew-face-eof-part ((t (:foreground ,sunburn-yellow))))
;;;;; mic-paren
   `(paren-face-match ((t (:foreground ,sunburn-cyan :background ,sunburn-bg :weight bold))))
   `(paren-face-mismatch ((t (:foreground ,sunburn-bg :background ,sunburn-magenta :weight bold))))
   `(paren-face-no-match ((t (:foreground ,sunburn-bg :background ,sunburn-red :weight bold))))
;;;;; mingus
   `(mingus-directory-face ((t (:foreground ,sunburn-blue))))
   `(mingus-pausing-face ((t (:foreground ,sunburn-magenta))))
   `(mingus-playing-face ((t (:foreground ,sunburn-cyan))))
   `(mingus-playlist-face ((t (:foreground ,sunburn-cyan ))))
   `(mingus-mark-face ((t (:bold t :foreground ,sunburn-magenta))))
   `(mingus-song-file-face ((t (:foreground ,sunburn-yellow))))
   `(mingus-artist-face ((t (:foreground ,sunburn-cyan))))
   `(mingus-album-face ((t (:underline t :foreground ,sunburn-red+1))))
   `(mingus-album-stale-face ((t (:foreground ,sunburn-red+1))))
   `(mingus-stopped-face ((t (:foreground ,sunburn-red))))
;;;;; nav
   `(nav-face-heading ((t (:foreground ,sunburn-yellow))))
   `(nav-face-button-num ((t (:foreground ,sunburn-cyan))))
   `(nav-face-dir ((t (:foreground ,sunburn-green))))
   `(nav-face-hdir ((t (:foreground ,sunburn-red))))
   `(nav-face-file ((t (:foreground ,sunburn-fg))))
   `(nav-face-hfile ((t (:foreground ,sunburn-red-4))))
;;;;; mu4e
   `(mu4e-cited-1-face ((t (:foreground ,sunburn-blue    :slant italic))))
   `(mu4e-cited-2-face ((t (:foreground ,sunburn-green+2 :slant italic))))
   `(mu4e-cited-3-face ((t (:foreground ,sunburn-blue-2  :slant italic))))
   `(mu4e-cited-4-face ((t (:foreground ,sunburn-green   :slant italic))))
   `(mu4e-cited-5-face ((t (:foreground ,sunburn-blue-4  :slant italic))))
   `(mu4e-cited-6-face ((t (:foreground ,sunburn-green-1 :slant italic))))
   `(mu4e-cited-7-face ((t (:foreground ,sunburn-blue    :slant italic))))
   `(mu4e-replied-face ((t (:foreground ,sunburn-bg+3))))
   `(mu4e-trashed-face ((t (:foreground ,sunburn-bg+3 :strike-through t))))
;;;;; mumamo
   `(mumamo-background-chunk-major ((t (:background nil))))
   `(mumamo-background-chunk-submode1 ((t (:background ,sunburn-bg-1))))
   `(mumamo-background-chunk-submode2 ((t (:background ,sunburn-bg+2))))
   `(mumamo-background-chunk-submode3 ((t (:background ,sunburn-bg+3))))
   `(mumamo-background-chunk-submode4 ((t (:background ,sunburn-bg+1))))
;;;;; neotree
   `(neo-banner-face ((t (:foreground ,sunburn-blue+1 :weight bold))))
   `(neo-header-face ((t (:foreground ,sunburn-fg))))
   `(neo-root-dir-face ((t (:foreground ,sunburn-blue+1 :weight bold))))
   `(neo-dir-link-face ((t (:foreground ,sunburn-blue))))
   `(neo-file-link-face ((t (:foreground ,sunburn-fg))))
   `(neo-expand-btn-face ((t (:foreground ,sunburn-blue))))
   `(neo-vc-default-face ((t (:foreground ,sunburn-fg+1))))
   `(neo-vc-user-face ((t (:foreground ,sunburn-red :slant italic))))
   `(neo-vc-up-to-date-face ((t (:foreground ,sunburn-fg))))
   `(neo-vc-edited-face ((t (:foreground ,sunburn-magenta))))
   `(neo-vc-needs-merge-face ((t (:foreground ,sunburn-red+1))))
   `(neo-vc-unlocked-changes-face ((t (:foreground ,sunburn-red :background ,sunburn-blue-5))))
   `(neo-vc-added-face ((t (:foreground ,sunburn-green+1))))
   `(neo-vc-conflict-face ((t (:foreground ,sunburn-red+1))))
   `(neo-vc-missing-face ((t (:foreground ,sunburn-red+1))))
   `(neo-vc-ignored-face ((t (:foreground ,sunburn-fg-1))))
;;;;; org-mode
   `(org-agenda-date-today
     ((t (:background ,sunburn-bg :foreground ,sunburn-fg+1 :slant italic :weight bold))) t)
   `(org-agenda-clocking
     ((t (:background ,sunburn-bg :foreground ,sunburn-blue+1))) t)
   `(org-agenda-column-dateline
     ((t (:background ,sunburn-bg :foreground ,sunburn-yellow-1))) t)
   `(org-agenda-structure
     ((t (:inherit font-lock-comment-face))))
   `(org-agenda-dimmed-todo-face ((t (:background ,sunburn-red-1 :foreground ,sunburn-bg-1))))
   `(org-archived ((t (:foreground ,sunburn-fg :weight bold))))
   `(org-checkbox ((t (:background ,sunburn-bg+2 :foreground ,sunburn-fg+1
                                   :box (:line-width 1 :style released-button)))))
   `(org-date ((t (:foreground ,sunburn-blue :underline t))))
   `(org-deadline-announce ((t (:foreground ,sunburn-red-1))))
   `(org-formula ((t (:foreground ,sunburn-yellow-2))))
   `(org-headline-done ((t (:foreground ,sunburn-green+3))))
   `(org-hide ((t (:foreground ,sunburn-bg-1))))
   `(org-level-1 ((t (:weight bold :foreground ,sunburn-yellow))))
   `(org-level-2 ((t (:weight bold :foreground ,sunburn-blue+1))))
   `(org-level-3 ((t (:weight bold :foreground ,sunburn-orange))))
   `(org-level-4 ((t (:weight bold :foreground ,sunburn-cyan))))
   `(org-level-5 ((t (:weight bold :foreground ,sunburn-green))))
   `(org-level-6 ((t (:weight bold :foreground ,sunburn-red))))
   `(org-level-7 ((t (:foreground ,sunburn-yellow))))
   `(org-level-8 ((t (:foreground ,sunburn-blue+1))))
   `(org-link ((t (:foreground ,sunburn-yellow :underline t))))
   `(org-ref-acronym-face ((t (:foreground ,sunburn-gold :underline t))))
   `(org-ref-cite-face ((t (:foreground ,sunburn-green :underline t))))
   `(org-ref-glossary-face ((t (:foreground ,sunburn-blue :underline t))))
   `(org-ref-label-face ((t (:foreground ,sunburn-magenta :underline t))))
   `(org-ref-ref-face ((t (:foreground ,sunburn-red-2 :underline t))))
   `(org-verbatim ((,class (:weight bold :background ,sunburn-bg :foreground ,sunburn-blue+1))))
   `(org-quote ((,class (:weight bold :background ,sunburn-bg :foreground ,sunburn-blue+1))))
   `(org-code ((,class (:weight bold :background ,sunburn-bg :foreground ,sunburn-blue+1))))
   `(org-scheduled ((t (:foreground ,sunburn-green+4))))
   `(org-scheduled-previously ((t (:foreground ,sunburn-red))))
   `(org-scheduled-today ((t (:foreground ,sunburn-blue))))
   `(org-special-keyword ((t (:foreground ,sunburn-cyan))))
   `(org-special-properties ((t (:foreground ,sunburn-cyan))))
   `(org-sexp-date ((t (:foreground ,sunburn-cyan :underline t))))
   `(org-meta-line ((t (:foreground ,sunburn-yellow-1))))
   ;; `(org-table ((t (:foreground ,sunburn-fg))))
   `(org-table ((t :background ,sunburn-bg :foreground ,sunburn-cyan)))
   `(org-priority ((t (:background ,sunburn-bg :foreground ,sunburn-red :weight bold))))
   `(org-tag ((t (:background ,sunburn-bg :weight bold))))
   `(org-tag-group ((t (:background ,sunburn-bg :weight bold))))
   `(org-special-keyword ((t (:background ,sunburn-bg :weight bold))))
   `(org-time-grid ((t (:foreground ,sunburn-orange))))
   `(org-kbd ((t :background ,sunburn-gold :foreground ,sunburn-bg-05 :weight bold)))
   `(org-done ((t :background ,sunburn-bg :foreground ,sunburn-green+3)))
   `(org-todo ((t :background ,sunburn-bg :foreground ,sunburn-red)))
   `(org-upcoming-deadline ((t (:inherit font-lock-keyword-face))))
   `(org-warning ((t (:weight bold :foreground ,sunburn-red :weight bold :underline nil))))
   `(org-column ((t (:background ,sunburn-bg-1))))
   `(org-column-title ((t (:background ,sunburn-bg-1 :underline t :weight bold))))
   `(org-mode-line-clock ((t (:foreground ,sunburn-fg :background ,sunburn-bg-1))))
   `(org-mode-line-clock-overrun ((t (:foreground ,sunburn-bg :background ,sunburn-red-1))))
   `(org-ellipsis ((t (:foreground ,sunburn-yellow-1 :underline t))))
   `(org-footnote ((t (:foreground ,sunburn-cyan :underline t))))
   `(org-date ((t (:foreground ,sunburn-cyan :underline t))))
   `(org-property-value ((t (:foreground ,sunburn-magenta :underline t))))
   `(org-document-title ((t (:background ,sunburn-bg :foreground ,sunburn-blue :height 1.4))))
   `(org-document-info ((t (:background ,sunburn-bg :foreground ,sunburn-blue :height 1.2))))
   `(org-document-info-keyword ((t (:background ,sunburn-bg :foreground ,sunburn-green :height 1.2))))
   `(org-habit-ready-face ((t :background ,sunburn-green)))
   `(org-habit-alert-face ((t :background ,sunburn-yellow-1 :foreground ,sunburn-bg)))
   `(org-habit-clear-face ((t :background ,sunburn-blue-3)))
   `(org-habit-overdue-face ((t :background ,sunburn-red-3)))
   `(org-habit-clear-future-face ((t :background ,sunburn-blue-4)))
   `(org-habit-ready-future-face ((t :background ,sunburn-green-1)))
   `(org-habit-alert-future-face ((t :background ,sunburn-yellow-2 :foreground ,sunburn-bg)))
   `(org-habit-overdue-future-face ((t :background ,sunburn-red-4)))
   `(org-block-begin-line ((t :background ,sunburn-bg-1 :foreground ,sunburn-yellow)))
   `(org-block-end-line ((t :background ,sunburn-bg-1 :foreground ,sunburn-yellow)))
   `(org-block ((t :background ,sunburn-bg :foreground ,sunburn-fg+1)))
;;;;; ein
   `(ein:cell-input-prompt ((t (:foreground ,sunburn-cyan))))
   `(ein:cell-input-area ((t :background ,sunburn-bg-1)))
   `(ein:cell-heading-1 ((t (:weight bold :foreground ,sunburn-yellow))))
   `(ein:cell-heading-2 ((t (:weight bold :foreground ,sunburn-blue+1))))
   `(ein:cell-heading-3 ((t (:weight bold :foreground ,sunburn-orange))))
   `(ein:cell-heading-4 ((t (:weight bold :foreground ,sunburn-cyan))))
   `(ein:cell-heading-5 ((t (:weight bold :foreground ,sunburn-green))))
   `(ein:cell-heading-6 ((t (:weight bold :foreground ,sunburn-red))))
   `(ein:cell-output-stderr ((t (:weight bold :foreground ,sunburn-red :weight bold :underline nil))))
   `(ein:cell-output-prompt ((t (:foreground ,sunburn-green+3))))
;;;;; outline
   `(outline-1 ((t (:foreground ,sunburn-orange))))
   `(outline-2 ((t (:foreground ,sunburn-green+4))))
   `(outline-3 ((t (:foreground ,sunburn-blue-1))))
   `(outline-4 ((t (:foreground ,sunburn-yellow-2))))
   `(outline-5 ((t (:foreground ,sunburn-cyan))))
   `(outline-6 ((t (:foreground ,sunburn-green+2))))
   `(outline-7 ((t (:foreground ,sunburn-red-4))))
   `(outline-8 ((t (:foreground ,sunburn-blue-4))))
;;;;; p4
   `(p4-depot-added-face ((t :inherit diff-added)))
   `(p4-depot-branch-op-face ((t :inherit diff-changed)))
   `(p4-depot-deleted-face ((t :inherit diff-removed)))
   `(p4-depot-unmapped-face ((t :inherit diff-changed)))
   `(p4-diff-change-face ((t :inherit diff-changed)))
   `(p4-diff-del-face ((t :inherit diff-removed)))
   `(p4-diff-file-face ((t :inherit diff-file-header)))
   `(p4-diff-head-face ((t :inherit diff-header)))
   `(p4-diff-ins-face ((t :inherit diff-added)))
;;;;; perspective
   `(persp-selected-face ((t (:foreground ,sunburn-yellow-2 :inherit mode-line))))
;;;;;
   `(powerline-active1 ((t (:background ,sunburn-bg-05 :inherit mode-line))))
   `(powerline-active2 ((t (:background ,sunburn-bg+2 :inherit mode-line))))
   `(powerline-inactive1 ((t (:background ,sunburn-bg+1 :inherit mode-line-inactive))))
   `(powerline-inactive2 ((t (:background ,sunburn-bg+3 :inherit mode-line-inactive))))
;;;;; proofgeneral
   `(proof-active-area-face ((t (:underline t))))
   `(proof-boring-face ((t (:foreground ,sunburn-fg :background ,sunburn-bg+2))))
   `(proof-command-mouse-highlight-face ((t (:inherit proof-mouse-highlight-face))))
   `(proof-debug-message-face ((t (:inherit proof-boring-face))))
   `(proof-declaration-name-face ((t (:inherit font-lock-keyword-face :foreground nil))))
   `(proof-eager-annotation-face ((t (:foreground ,sunburn-bg :background ,sunburn-orange))))
   `(proof-error-face ((t (:foreground ,sunburn-fg :background ,sunburn-red-4))))
   `(proof-highlight-dependency-face ((t (:foreground ,sunburn-bg :background ,sunburn-yellow-1))))
   `(proof-highlight-dependent-face ((t (:foreground ,sunburn-bg :background ,sunburn-orange))))
   `(proof-locked-face ((t (:background ,sunburn-blue-5))))
   `(proof-mouse-highlight-face ((t (:foreground ,sunburn-bg :background ,sunburn-orange))))
   `(proof-queue-face ((t (:background ,sunburn-red-4))))
   `(proof-region-mouse-highlight-face ((t (:inherit proof-mouse-highlight-face))))
   `(proof-script-highlight-error-face ((t (:background ,sunburn-red-2))))
   `(proof-tacticals-name-face ((t (:inherit font-lock-constant-face :foreground nil :background ,sunburn-bg))))
   `(proof-tactics-name-face ((t (:inherit font-lock-constant-face :foreground nil :background ,sunburn-bg))))
   `(proof-warning-face ((t (:foreground ,sunburn-bg :background ,sunburn-yellow-1))))
;;;;; racket-mode
   `(racket-keyword-argument-face ((t (:inherit font-lock-constant-face))))
   `(racket-selfeval-face ((t (:inherit font-lock-type-face))))
;;;;; rainbow-delimiters
   `(rainbow-delimiters-depth-1-face ((t (:foreground ,sunburn-fg))))
   `(rainbow-delimiters-depth-2-face ((t (:foreground ,sunburn-green+4))))
   `(rainbow-delimiters-depth-3-face ((t (:foreground ,sunburn-yellow-2))))
   `(rainbow-delimiters-depth-4-face ((t (:foreground ,sunburn-cyan))))
   `(rainbow-delimiters-depth-5-face ((t (:foreground ,sunburn-green+2))))
   `(rainbow-delimiters-depth-6-face ((t (:foreground ,sunburn-blue+1))))
   `(rainbow-delimiters-depth-7-face ((t (:foreground ,sunburn-yellow-1))))
   `(rainbow-delimiters-depth-8-face ((t (:foreground ,sunburn-green+1))))
   `(rainbow-delimiters-depth-9-face ((t (:foreground ,sunburn-blue-2))))
   `(rainbow-delimiters-depth-10-face ((t (:foreground ,sunburn-orange))))
   `(rainbow-delimiters-depth-11-face ((t (:foreground ,sunburn-green))))
   `(rainbow-delimiters-depth-12-face ((t (:foreground ,sunburn-blue-5))))
;;;;; rcirc
   `(rcirc-my-nick ((t (:foreground ,sunburn-blue))))
   `(rcirc-other-nick ((t (:foreground ,sunburn-orange))))
   `(rcirc-bright-nick ((t (:foreground ,sunburn-blue+1))))
   `(rcirc-dim-nick ((t (:foreground ,sunburn-blue-2))))
   `(rcirc-server ((t (:foreground ,sunburn-green))))
   `(rcirc-server-prefix ((t (:foreground ,sunburn-green+1))))
   `(rcirc-timestamp ((t (:foreground ,sunburn-green+2))))
   `(rcirc-nick-in-message ((t (:foreground ,sunburn-yellow))))
   `(rcirc-nick-in-message-full-line ((t (:weight bold))))
   `(rcirc-prompt ((t (:foreground ,sunburn-yellow :weight bold))))
   `(rcirc-track-nick ((t (:inverse-video t))))
   `(rcirc-track-keyword ((t (:weight bold))))
   `(rcirc-url ((t (:weight bold))))
   `(rcirc-keyword ((t (:foreground ,sunburn-yellow :weight bold))))
;;;;; re-builder
   `(reb-match-0 ((t (:foreground ,sunburn-bg :background ,sunburn-magenta))))
   `(reb-match-1 ((t (:foreground ,sunburn-bg :background ,sunburn-blue))))
   `(reb-match-2 ((t (:foreground ,sunburn-bg :background ,sunburn-orange))))
   `(reb-match-3 ((t (:foreground ,sunburn-bg :background ,sunburn-red))))
;;;;; regex-tool
   `(regex-tool-matched-face ((t (:background ,sunburn-blue-4 :weight bold))))
;;;;; rpm-mode
   `(rpm-spec-dir-face ((t (:foreground ,sunburn-green))))
   `(rpm-spec-doc-face ((t (:foreground ,sunburn-green))))
   `(rpm-spec-ghost-face ((t (:foreground ,sunburn-red))))
   `(rpm-spec-macro-face ((t (:foreground ,sunburn-yellow))))
   `(rpm-spec-obsolete-tag-face ((t (:foreground ,sunburn-red))))
   `(rpm-spec-package-face ((t (:foreground ,sunburn-red))))
   `(rpm-spec-section-face ((t (:foreground ,sunburn-yellow))))
   `(rpm-spec-tag-face ((t (:foreground ,sunburn-blue))))
   `(rpm-spec-var-face ((t (:foreground ,sunburn-red))))
;;;;; rst-mode
   `(rst-level-1-face ((t (:foreground ,sunburn-orange))))
   `(rst-level-2-face ((t (:foreground ,sunburn-green+1))))
   `(rst-level-3-face ((t (:foreground ,sunburn-blue-1))))
   `(rst-level-4-face ((t (:foreground ,sunburn-yellow-2))))
   `(rst-level-5-face ((t (:foreground ,sunburn-cyan))))
   `(rst-level-6-face ((t (:foreground ,sunburn-green-1))))
;;;;; sh-mode
   `(sh-heredoc     ((t (:foreground ,sunburn-yellow :weight bold))))
   `(sh-quoted-exec ((t (:foreground ,sunburn-red))))
;;;;; show-paren
   `(show-paren-mismatch ((t (:foreground ,sunburn-red+1 :background ,sunburn-bg+3 :weight bold))))
   `(show-paren-match ((t (:background ,sunburn-bg+3 :weight bold))))
;;;;; smart-mode-line
   ;; use (setq sml/theme nil) to enable Sunburn for sml
   `(sml/global ((,class (:foreground ,sunburn-fg :weight bold))))
   `(sml/modes ((,class (:foreground ,sunburn-yellow :weight bold))))
   `(sml/minor-modes ((,class (:foreground ,sunburn-fg-1 :weight bold))))
   `(sml/filename ((,class (:foreground ,sunburn-yellow :weight bold))))
   `(sml/line-number ((,class (:foreground ,sunburn-blue :weight bold))))
   `(sml/col-number ((,class (:foreground ,sunburn-blue+1 :weight bold))))
   `(sml/position-percentage ((,class (:foreground ,sunburn-blue-1 :weight bold))))
   `(sml/prefix ((,class (:foreground ,sunburn-orange))))
   `(sml/git ((,class (:foreground ,sunburn-green+3))))
   `(sml/process ((,class (:weight bold))))
   `(sml/sudo ((,class  (:foreground ,sunburn-orange :weight bold))))
   `(sml/read-only ((,class (:foreground ,sunburn-red-2))))
   `(sml/outside-modified ((,class (:foreground ,sunburn-orange))))
   `(sml/modified ((,class (:foreground ,sunburn-red))))
   `(sml/vc-edited ((,class (:foreground ,sunburn-green+2))))
   `(sml/charging ((,class (:foreground ,sunburn-green+4))))
   `(sml/discharging ((,class (:foreground ,sunburn-red+1))))
;;;;; smartparens
   `(sp-show-pair-mismatch-face ((t (:foreground ,sunburn-red+1 :background ,sunburn-bg+3 :weight bold))))
   `(sp-show-pair-match-face ((t (:background ,sunburn-bg+3 :weight bold))))
;;;;; sml-mode-line
   '(sml-modeline-end-face ((t :inherit default :width condensed)))
;;;;; SLIME
   `(slime-repl-output-face ((t (:foreground ,sunburn-red))))
   `(slime-repl-inputed-output-face ((t (:foreground ,sunburn-green))))
   `(slime-error-face
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-red)))
      (t
       (:underline ,sunburn-red))))
   `(slime-warning-face
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-orange)))
      (t
       (:underline ,sunburn-orange))))
   `(slime-style-warning-face
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-yellow)))
      (t
       (:underline ,sunburn-yellow))))
   `(slime-note-face
     ((((supports :underline (:style wave)))
       (:underline (:style wave :color ,sunburn-green)))
      (t
       (:underline ,sunburn-green))))
   `(slime-highlight-face ((t (:inherit highlight))))
;;;;; speedbar
   `(speedbar-button-face ((t (:foreground ,sunburn-green+2))))
   `(speedbar-directory-face ((t (:foreground ,sunburn-cyan))))
   `(speedbar-file-face ((t (:foreground ,sunburn-fg))))
   `(speedbar-highlight-face ((t (:foreground ,sunburn-bg :background ,sunburn-green+2))))
   `(speedbar-selected-face ((t (:foreground ,sunburn-red))))
   `(speedbar-separator-face ((t (:foreground ,sunburn-bg :background ,sunburn-blue-1))))
   `(speedbar-tag-face ((t (:foreground ,sunburn-yellow))))
;;;;; tabbar
   `(tabbar-button ((t (:foreground ,sunburn-fg
                                    :background ,sunburn-bg))))
   `(tabbar-selected ((t (:foreground ,sunburn-fg
                                      :background ,sunburn-bg
                                      :box (:line-width -1 :style pressed-button)))))
   `(tabbar-unselected ((t (:foreground ,sunburn-fg
                                        :background ,sunburn-bg+1
                                        :box (:line-width -1 :style released-button)))))
;;;;; term
   `(term-color-black ((t (:foreground ,sunburn-bg
                                       :background ,sunburn-bg-1))))
   `(term-color-red ((t (:foreground ,sunburn-red-2
                                     :background ,sunburn-red-4))))
   `(term-color-green ((t (:foreground ,sunburn-green
                                       :background ,sunburn-green+2))))
   `(term-color-yellow ((t (:foreground ,sunburn-orange
                                        :background ,sunburn-yellow))))
   `(term-color-blue ((t (:foreground ,sunburn-blue-1
                                      :background ,sunburn-blue-4))))
   `(term-color-magenta ((t (:foreground ,sunburn-magenta
                                         :background ,sunburn-red))))
   `(term-color-cyan ((t (:foreground ,sunburn-cyan
                                      :background ,sunburn-blue))))
   `(term-color-white ((t (:foreground ,sunburn-fg
                                       :background ,sunburn-fg-1))))
   '(term-default-fg-color ((t (:inherit term-color-white))))
   '(term-default-bg-color ((t (:inherit term-color-black))))
;;;;; undo-tree
   `(undo-tree-visualizer-active-branch-face ((t (:foreground ,sunburn-fg+1 :weight bold))))
   `(undo-tree-visualizer-current-face ((t (:foreground ,sunburn-red-1 :weight bold))))
   `(undo-tree-visualizer-default-face ((t (:foreground ,sunburn-fg))))
   `(undo-tree-visualizer-register-face ((t (:foreground ,sunburn-yellow))))
   `(undo-tree-visualizer-unmodified-face ((t (:foreground ,sunburn-cyan))))
;;;;; visual-regexp
   `(vr/group-0 ((t (:foreground ,sunburn-bg :background ,sunburn-green :weight bold))))
   `(vr/group-1 ((t (:foreground ,sunburn-bg :background ,sunburn-orange :weight bold))))
   `(vr/group-2 ((t (:foreground ,sunburn-bg :background ,sunburn-blue :weight bold))))
   `(vr/match-0 ((t (:inherit isearch))))
   `(vr/match-1 ((t (:foreground ,sunburn-yellow-2 :background ,sunburn-bg-1 :weight bold))))
   `(vr/match-separator-face ((t (:foreground ,sunburn-red :weight bold))))
;;;;; volatile-highlights
   `(vhl/default-face ((t (:background ,sunburn-bg-05))))
;;;;; web-mode
   `(web-mode-builtin-face ((t (:inherit ,font-lock-builtin-face))))
   `(web-mode-comment-face ((t (:inherit ,font-lock-comment-face))))
   `(web-mode-constant-face ((t (:inherit ,font-lock-constant-face))))
   `(web-mode-css-at-rule-face ((t (:foreground ,sunburn-orange ))))
   `(web-mode-css-prop-face ((t (:foreground ,sunburn-orange))))
   `(web-mode-css-pseudo-class-face ((t (:foreground ,sunburn-green+3 :weight bold))))
   `(web-mode-css-rule-face ((t (:foreground ,sunburn-blue))))
   `(web-mode-doctype-face ((t (:inherit ,font-lock-comment-face))))
   `(web-mode-folded-face ((t (:underline t))))
   `(web-mode-function-name-face ((t (:foreground ,sunburn-blue))))
   `(web-mode-html-attr-name-face ((t (:foreground ,sunburn-orange))))
   `(web-mode-html-attr-value-face ((t (:inherit ,font-lock-string-face))))
   `(web-mode-html-tag-face ((t (:foreground ,sunburn-cyan))))
   `(web-mode-keyword-face ((t (:inherit ,font-lock-keyword-face))))
   `(web-mode-preprocessor-face ((t (:inherit ,font-lock-preprocessor-face))))
   `(web-mode-string-face ((t (:inherit ,font-lock-string-face))))
   `(web-mode-type-face ((t (:inherit ,font-lock-type-face))))
   `(web-mode-variable-name-face ((t (:inherit ,font-lock-variable-name-face))))
   `(web-mode-server-background-face ((t (:background ,sunburn-bg))))
   `(web-mode-server-comment-face ((t (:inherit web-mode-comment-face))))
   `(web-mode-server-string-face ((t (:inherit web-mode-string-face))))
   `(web-mode-symbol-face ((t (:inherit font-lock-constant-face))))
   `(web-mode-warning-face ((t (:inherit font-lock-warning-face))))
   `(web-mode-whitespaces-face ((t (:background ,sunburn-red))))
;;;;; whitespace-mode
   `(whitespace-space ((t (:background ,sunburn-bg+1 :foreground ,sunburn-bg+1))))
   `(whitespace-hspace ((t (:background ,sunburn-bg+1 :foreground ,sunburn-bg+1))))
   `(whitespace-tab ((t (:background ,sunburn-red-1))))
   `(whitespace-newline ((t (:foreground ,sunburn-bg+1))))
   `(whitespace-trailing ((t (:background ,sunburn-red))))
   `(whitespace-line ((t (:background ,sunburn-bg :foreground ,sunburn-magenta))))
   `(whitespace-space-before-tab ((t (:background ,sunburn-orange :foreground ,sunburn-orange))))
   `(whitespace-indentation ((t (:background ,sunburn-yellow :foreground ,sunburn-red))))
   `(whitespace-empty ((t (:background ,sunburn-yellow))))
   `(whitespace-space-after-tab ((t (:background ,sunburn-yellow :foreground ,sunburn-red))))
;;;;; wanderlust
   `(wl-highlight-folder-few-face ((t (:foreground ,sunburn-red-2))))
   `(wl-highlight-folder-many-face ((t (:foreground ,sunburn-red-1))))
   `(wl-highlight-folder-path-face ((t (:foreground ,sunburn-orange))))
   `(wl-highlight-folder-unread-face ((t (:foreground ,sunburn-blue))))
   `(wl-highlight-folder-zero-face ((t (:foreground ,sunburn-fg))))
   `(wl-highlight-folder-unknown-face ((t (:foreground ,sunburn-blue))))
   `(wl-highlight-message-citation-header ((t (:foreground ,sunburn-red-1))))
   `(wl-highlight-message-cited-text-1 ((t (:foreground ,sunburn-red))))
   `(wl-highlight-message-cited-text-2 ((t (:foreground ,sunburn-green+2))))
   `(wl-highlight-message-cited-text-3 ((t (:foreground ,sunburn-blue))))
   `(wl-highlight-message-cited-text-4 ((t (:foreground ,sunburn-blue+1))))
   `(wl-highlight-message-header-contents-face ((t (:foreground ,sunburn-green))))
   `(wl-highlight-message-headers-face ((t (:foreground ,sunburn-red+1))))
   `(wl-highlight-message-important-header-contents ((t (:foreground ,sunburn-green+2))))
   `(wl-highlight-message-header-contents ((t (:foreground ,sunburn-green+1))))
   `(wl-highlight-message-important-header-contents2 ((t (:foreground ,sunburn-green+2))))
   `(wl-highlight-message-signature ((t (:foreground ,sunburn-green))))
   `(wl-highlight-message-unimportant-header-contents ((t (:foreground ,sunburn-fg))))
   `(wl-highlight-summary-answered-face ((t (:foreground ,sunburn-blue))))
   `(wl-highlight-summary-disposed-face ((t (:foreground ,sunburn-fg
                                                         :slant italic))))
   `(wl-highlight-summary-new-face ((t (:foreground ,sunburn-blue))))
   `(wl-highlight-summary-normal-face ((t (:foreground ,sunburn-fg))))
   `(wl-highlight-summary-thread-top-face ((t (:foreground ,sunburn-yellow))))
   `(wl-highlight-thread-indent-face ((t (:foreground ,sunburn-magenta))))
   `(wl-highlight-summary-refiled-face ((t (:foreground ,sunburn-fg))))
   `(wl-highlight-summary-displaying-face ((t (:underline t :weight bold))))
;;;;; which-func-mode
   `(which-func ((t (:foreground ,sunburn-green+4))))
;;;;; xcscope
   `(cscope-file-face ((t (:foreground ,sunburn-yellow :weight bold))))
   `(cscope-function-face ((t (:foreground ,sunburn-cyan :weight bold))))
   `(cscope-line-number-face ((t (:foreground ,sunburn-red :weight bold))))
   `(cscope-mouse-face ((t (:foreground ,sunburn-bg :background ,sunburn-blue+1))))
   `(cscope-separator-face ((t (:foreground ,sunburn-red :weight bold
                                            :underline t :overline t))))
;;;;; yascroll
   `(yascroll:thumb-text-area ((t (:background ,sunburn-bg-1))))
   `(yascroll:thumb-fringe ((t (:background ,sunburn-bg-1 :foreground ,sunburn-bg-1))))
   ))

;;; Theme Variables
(sunburn-with-color-variables
  (custom-theme-set-variables
   'sunburn
;;;;; ansi-color
   `(ansi-color-names-vector [,sunburn-bg ,sunburn-red ,sunburn-green ,sunburn-yellow
                                          ,sunburn-blue ,sunburn-magenta ,sunburn-cyan ,sunburn-fg])
;;;;; fill-column-indicator
   `(fci-rule-color ,sunburn-bg-05)
;;;;; nrepl-client
   `(nrepl-message-colors
     '(,sunburn-red ,sunburn-orange ,sunburn-yellow ,sunburn-green ,sunburn-green+4
                    ,sunburn-cyan ,sunburn-blue+1 ,sunburn-magenta))
;;;;; pdf-tools
   `(pdf-view-midnight-colors '(,sunburn-fg . ,sunburn-bg-05))
;;;;; vc-annotate
   `(vc-annotate-color-map
     '(( 20. . ,sunburn-red-1)
       ( 40. . ,sunburn-red)
       ( 60. . ,sunburn-orange)
       ( 80. . ,sunburn-yellow-2)
       (100. . ,sunburn-yellow-1)
       (120. . ,sunburn-yellow)
       (140. . ,sunburn-green-1)
       (160. . ,sunburn-green)
       (180. . ,sunburn-green+1)
       (200. . ,sunburn-green+2)
       (220. . ,sunburn-green+3)
       (240. . ,sunburn-green+4)
       (260. . ,sunburn-cyan)
       (280. . ,sunburn-blue-2)
       (300. . ,sunburn-blue-1)
       (320. . ,sunburn-blue)
       (340. . ,sunburn-blue+1)
       (360. . ,sunburn-magenta)))
   `(vc-annotate-very-old-color ,sunburn-magenta)
   `(vc-annotate-background ,sunburn-bg-1)
   ))

;;;###autoload
(and load-file-name
     (boundp 'custom-theme-load-path)
     (add-to-list 'custom-theme-load-path
                  (file-name-as-directory
                   (file-name-directory load-file-name))))

(provide-theme 'sunburn)

;; Local Variables:
;; no-byte-compile: t
;; indent-tabs-mode: nil
;; End:
;;; sunburn-theme.el ends here



;;; free-keys.el --- Show free keybindings for modkeys or prefixes

;; Copyright (C) 2013 Matus Goljer

;; Author: Matus Goljer <matus.goljer@gmail.com>
;; Maintainer: Matus Goljer <matus.goljer@gmail.com>
;; Version: 0.1
;; Created: 3rd November 2013
;; Keywords: convenience
;; Package-Requires: ((cl-lib "0.3"))
;; URL: https://github.com/Fuco1/free-keys

;; This file is not part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Show free keybindings for modkeys or prefixes. Based on code
;; located here: https://gist.github.com/bjorne/3796607
;;
;; For complete description see https://github.com/Fuco1/free-keys

;;; Code:

(require 'cl-lib)

(defgroup free-keys ()
  "Free keys."
  :group 'convenience)

(defcustom free-keys-modifiers '("" "C" "M" "C-M")
  "List of modifiers that can be used in front of keys."
  :type '(repeat string)
  :group 'free-keys)

(defcustom free-keys-keys "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-=[]{};'\\:\"|,./<>?`~"
  "String or list of keys that can be used as bindings.

In case of string, each letter is interpreted as a character to
test.

In case of list, each item is considered as key code.  This
allows you to add keys such as TAB or RET."
  :type '(choice
          (string :tag "String of characters")
          (repeat :tag "List of characters" string))
  :group 'free-keys)

(defcustom free-keys-ignored-bindings nil
  "List of bindings with modifiers which should never be considered free.

The elements could be either strings of form \"MOD-KEY\" or cons
where the car is a single letter modifier as in
`free-keys-modifiers' and the cdr is a string containing keys to
be ignored with this modifiers, like `free-keys-keys'.

The bindings should not contain a prefix.  This can typically be
used to ignore bindings intercepted by the window manager used
for swapping windows and similar operations."
  :type '(repeat (choice (string :tag "Key binding")
                         (cons :tag "Modifier and string of key bindings"
                               (string :tag "Modifier")
                               (string :tag "Key bindings"))))
  :group 'free-keys)

(defun free-keys-ignored-bindings ()
  "Return a list of bindings that should never be considered free.

The elements of the returned list are of form \"MOD-KEY\".

See also the variable `free-keys-ignored-bindings'."
  (apply 'append
         (mapcar (lambda (x)
                   (if (stringp x) (list x)
                     (mapcar (lambda (y)
                               (concat (car x) "-" (char-to-string y)))
                             (cdr x))))
                 free-keys-ignored-bindings)))

(defvar free-keys-mode-map
  (let ((map (make-keymap)))
    (define-key map "b" 'free-keys-change-buffer)
    (define-key map "p" 'free-keys-set-prefix)
    map)
  "Keymap for Free Keys mode.")

(defvar free-keys-original-buffer nil
  "Buffer from which `free-keys' was called.")

(defun free-keys--print-in-columns (key-list &optional columns)
  "Print the KEY-LIST into as many columns as will fit into COLUMNS characters.

The columns are ordered according to variable `free-keys-keys',
advancing down-right.  The margin between each column is 5 characters."
  (setq columns (or columns 80))
  (let* ((len (+ 5 (length (car key-list))))
         (num-of-keys (length key-list))
         (cols (/ columns len))
         (rows (1+ (/ num-of-keys cols)))
         (rem (mod num-of-keys cols))
         (cur-col 0)
         (cur-row 0))
    (dotimes (i num-of-keys)
      (insert (nth
               (+ (* cur-col rows) cur-row (if (> cur-col rem) (- rem cur-col) 0))
               key-list)
              "     ")
      (cl-incf cur-col)
      (when (= cur-col cols)
        (insert "\n")
        (setq cur-col 0)
        (cl-incf cur-row)))))

(defun free-keys-set-prefix (prefix)
  "Change the prefix in current *Free keys* buffer to PREFIX and
update the display."
  (interactive "sPrefix: ")
  (free-keys prefix free-keys-original-buffer))

(defun free-keys-change-buffer (buffer)
  "Change the buffer for which the bindings are displayed to
BUFFER and update the display."
  (interactive "bShow free bindings for buffer: ")
  (free-keys nil (get-buffer-create buffer)))

(defun free-keys-revert-buffer (_ignore-auto _noconfirm)
  "Revert the *Free keys* buffer.

This simply calls `free-keys'."
  (free-keys nil free-keys-original-buffer))

(defun free-keys--process-modifier (prefix modifier)
  "Process free bindings for MODIFIER."
  (let (empty-keys)
    (mapc (lambda (key)
            (let* ((key-as-string (cond
                                   ((characterp key) (char-to-string key))
                                   ((stringp key) key)
                                   (t (error "Key is not a character nor a string"))))
                   (key-name
                    (if (not (equal modifier ""))
                        (concat modifier "-" key-as-string)
                      key-as-string))
                   (full-name
                    (if (and prefix (not (equal prefix ""))) (concat prefix " " key-name) key-name))
                   (binding
                    (with-current-buffer free-keys-original-buffer (key-binding (read-kbd-macro full-name)))))
              (when (and (not (member key-name (free-keys-ignored-bindings)))
                         (or (not binding)
                             (eq binding 'undefined)))
                (push full-name empty-keys))))
          free-keys-keys)
    (let ((len (length empty-keys)))
      (when (> len 0)
        (if (not (equal modifier ""))
            (insert (format "With modifier %s (%d free)\n=========================\n" modifier len))
          (insert (format "With no modifier (%d free)\n=========================\n" len)))
        (free-keys--print-in-columns (nreverse empty-keys))
        (insert "\n\n")))))

;;;###autoload
(defun free-keys (&optional prefix buffer)
  "Display free keys in current buffer.

A free key is a key that has no associated key-binding as
determined by function `key-binding'.

By default, keys on `free-keys-keys' list with no prefix sequence
are considered, possibly together with modifier keys from
`free-keys-modifiers'.  You can change the prefix sequence by
hitting 'p' in the *Free keys* buffer.  Prefix is supplied in
format recognized by `kbd', for example \"C-x\"."
  (interactive (list (when current-prefix-arg
                       (read-from-minibuffer "Prefix: "))))
  (setq prefix (or prefix ""))
  (setq free-keys-original-buffer (or buffer (current-buffer)))
  (let ((buf (get-buffer-create "*Free keys*")))
    (pop-to-buffer buf)
    (with-current-buffer buf
      (if (fboundp 'read-only-mode)
          (read-only-mode -1)
        (setq buffer-read-only nil))
      (erase-buffer)
      (insert "Free keys"
              (if (not (equal prefix "")) (format " with prefix %s" prefix) "")
              " in buffer "
              (buffer-name free-keys-original-buffer)
              " (major mode: " (with-current-buffer free-keys-original-buffer (symbol-name major-mode)) ")\n\n")
      (mapc (lambda (m) (free-keys--process-modifier prefix m)) free-keys-modifiers)
      (setq buffer-read-only t)
      (goto-char 0)
      (free-keys-mode))))

(define-derived-mode free-keys-mode special-mode "Free Keys"
  "Free keys mode.

Display the free keybindings in current buffer.

\\{free-keys-mode-map}"
  (set (make-local-variable 'revert-buffer-function) 'free-keys-revert-buffer)
  (set (make-local-variable 'header-line-format) "Help: (b) change buffer (p) change prefix (q) quit"))

(provide 'free-keys)
;;; free-keys.el ends here


;;; lua-mode.el --- a major-mode for editing Lua scripts

;; Author: 2011-2013 immerrr <immerrr+lua@gmail.com>
;;         2010-2011 Reuben Thomas <rrt@sc3d.org>
;;         2006 Juergen Hoetzel <juergen@hoetzel.info>
;;         2004 various (support for Lua 5 and byte compilation)
;;         2001 Christian Vogler <cvogler@gradient.cis.upenn.edu>
;;         1997 Bret Mogilefsky <mogul-lua@gelatinous.com> starting from
;;              tcl-mode by Gregor Schmid <schmid@fb3-s7.math.tu-berlin.de>
;;              with tons of assistance from
;;              Paul Du Bois <pld-lua@gelatinous.com> and
;;              Aaron Smith <aaron-lua@gelatinous.com>.
;;
;; URL:         http://immerrr.github.com/lua-mode
;; Version:     20151025
;;
;; This file is NOT part of Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 2
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software
;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
;; MA 02110-1301, USA.

;; Keywords: languages, processes, tools

;; This field is expanded to commit SHA, date & associated heads/tags during
;; archive creation.
;; Revision: $Format:%h (%cD %d)$
;;

;;; Commentary:

;; lua-mode provides support for editing Lua, including automatical
;; indentation, syntactical font-locking, running interactive shell,
;; interacting with `hs-minor-mode' and online documentation lookup.

;; The following variables are available for customization (see more via
;; `M-x customize-group lua`):

;; - Var `lua-indent-level':
;;   indentation offset in spaces
;; - Var `lua-indent-string-contents':
;;   set to `t` if you like to have contents of multiline strings to be
;;   indented like comments
;; - Var `lua-mode-hook':
;;   list of functions to execute when lua-mode is initialized
;; - Var `lua-documentation-url':
;;   base URL for documentation lookup
;; - Var `lua-documentation-function': function used to
;;   show documentation (`eww` is a viable alternative for Emacs 25)

;; These are variables/commands that operate on the Lua process:

;; - Var `lua-default-application':
;;   command to start the Lua process (REPL)
;; - Var `lua-default-command-switches':
;;   arguments to pass to the Lua process on startup (make sure `-i` is there
;;   if you expect working with Lua shell interactively)
;; - Cmd `lua-start-process': start new REPL process, usually happens automatically
;; - Cmd `lua-kill-process': kill current REPL process

;; These are variables/commands for interaction with the Lua process:

;; - Cmd `lua-show-process-buffer': switch to REPL buffer
;; - Cmd `lua-hide-process-buffer': hide window showing REPL buffer
;; - Var `lua-always-show': show REPL buffer after sending something
;; - Cmd `lua-send-buffer': send whole buffer
;; - Cmd `lua-send-current-line': send current line
;; - Cmd `lua-send-defun': send current top-level function
;; - Cmd `lua-send-region': send active region
;; - Cmd `lua-restart-with-whole-file': restart REPL and send whole buffer

;; See "M-x apropos-command ^lua-" for a list of commands.
;; See "M-x customize-group lua" for a list of customizable variables.


;;; Code:
(eval-when-compile
  (require 'cl))

(require 'comint)
(require 'newcomment)
(require 'rx)


;; rx-wrappers for Lua

(eval-when-compile
  ;; Silence compilation warning about `compilation-error-regexp-alist' defined
  ;; in compile.el.
  (require 'compile))

(eval-and-compile
  (defvar lua-rx-constituents)
  (defvar rx-parent)

  (defun lua-rx-to-string (form &optional no-group)
    "Lua-specific replacement for `rx-to-string'.

See `rx-to-string' documentation for more information FORM and
NO-GROUP arguments."
    (let ((rx-constituents lua-rx-constituents))
      (rx-to-string form no-group)))

  (defmacro lua-rx (&rest regexps)
    "Lua-specific replacement for `rx'.

See `rx' documentation for more information about REGEXPS param."
    (cond ((null regexps)
           (error "No regexp"))
          ((cdr regexps)
           (lua-rx-to-string `(and ,@regexps) t))
          (t
           (lua-rx-to-string (car regexps) t))))

  (defun lua--new-rx-form (form)
    "Add FORM definition to `lua-rx' macro.

FORM is a cons (NAME . DEFN), see more in `rx-constituents' doc.
This function enables specifying new definitions using old ones:
if DEFN is a list that starts with `:rx' symbol its second
element is itself expanded with `lua-rx-to-string'. "
    (let ((name (car form))
          (form-definition (cdr form)))
      (when (and (listp form-definition) (eq ':rx (car form-definition)))
        (setcdr form (lua-rx-to-string (cadr form-definition) 'nogroup)))
      (push form lua-rx-constituents)))

  (defun lua--rx-symbol (form)
    ;; form is a list (symbol XXX ...)
    ;; Skip initial 'symbol
    (setq form (cdr form))
    ;; If there's only one element, take it from the list, otherwise wrap the
    ;; whole list into `(or XXX ...)' form.
    (setq form (if (eq 1 (length form))
                   (car form)
                 (append '(or) form)))
    (rx-form `(seq symbol-start ,form symbol-end) rx-parent))

  (setq lua-rx-constituents (copy-sequence rx-constituents))

  (mapc #'lua--new-rx-form
        `((symbol lua--rx-symbol 1 nil)
          (ws . "[ \t]*") (ws+ . "[ \t]+")
          (lua-name :rx (symbol (regexp "[[:alpha:]_]+[[:alnum:]_]*")))
          (lua-funcname
           :rx (seq lua-name (* ws "." ws lua-name)
                    (opt ws ":" ws lua-name)))
          (lua-funcheader
           ;; Outer (seq ...) is here to shy-group the definition
           :rx (seq (or (seq (symbol "function") ws (group-n 1 lua-funcname))
                        (seq (group-n 1 lua-funcname) ws "=" ws
                             (symbol "function")))))
          (lua-number
           :rx (seq (or (seq (+ digit) (opt ".") (* digit))
                        (seq (* digit) (opt ".") (+ digit)))
                    (opt (regexp "[eE][+-]?[0-9]+"))))
          (lua-assignment-op
           :rx (seq "=" (or buffer-end (not (any "=")))))
          (lua-token
           :rx (or "+" "-" "*" "/" "%" "^" "#" "==" "~=" "<=" ">=" "<"
                   ">" "=" ";" ":" "," "." ".." "..."))
          (lua-keyword
           :rx (symbol "and" "break" "do" "else" "elseif" "end"  "for" "function"
                       "goto" "if" "in" "local" "not" "or" "repeat" "return"
                       "then" "until" "while")))
        ))


;; Local variables
(defgroup lua nil
  "Major mode for editing Lua code."
  :prefix "lua-"
  :group 'languages)

(defcustom lua-indent-level 3
  "Amount by which Lua subexpressions are indented."
  :type 'integer
  :group 'lua
  :safe #'integerp)

(defcustom lua-comment-start "-- "
  "Default value of `comment-start'."
  :type 'string
  :group 'lua)

(defcustom lua-comment-start-skip "---*[ \t]*"
  "Default value of `comment-start-skip'."
  :type 'string
  :group 'lua)

(defcustom lua-default-application "lua"
  "Default application to run in Lua process."
  :type '(choice (string)
                 (cons string integer))
  :group 'lua)

(defcustom lua-default-command-switches (list "-i")
  "Command switches for `lua-default-application'.
Should be a list of strings."
  :type '(repeat string)
  :group 'lua)
(make-variable-buffer-local 'lua-default-command-switches)

(defcustom lua-always-show t
  "*Non-nil means display lua-process-buffer after sending a command."
  :type 'boolean
  :group 'lua)

(defcustom lua-documentation-function 'browse-url
  "Function used to fetch the Lua reference manual."
  :type `(radio (function-item browse-url)
                ,@(when (fboundp 'eww) '((function-item eww)))
                ,@(when (fboundp 'w3m-browse-url) '((function-item w3m-browse-url)))
                (function :tag "Other function"))
  :group 'lua)

(defcustom lua-documentation-url
  (or (and (file-readable-p "/usr/share/doc/lua/manual.html")
           "file:///usr/share/doc/lua/manual.html")
      "http://www.lua.org/manual/5.1/manual.html")
  "URL pointing to the Lua reference manual."
  :type 'string
  :group 'lua)


(defvar lua-process nil
  "The active Lua process")

(defvar lua-process-buffer nil
  "Buffer used for communication with the Lua process")

(defun lua--customize-set-prefix-key (prefix-key-sym prefix-key-val)
  (cl-assert (eq prefix-key-sym 'lua-prefix-key))
  (set prefix-key-sym (if (and prefix-key-val (> (length prefix-key-val) 0))
                          ;; read-kbd-macro returns a string or a vector
                          ;; in both cases (elt x 0) is ok
                          (elt (read-kbd-macro prefix-key-val) 0)))
  (if (fboundp 'lua-prefix-key-update-bindings)
      (lua-prefix-key-update-bindings)))

(defcustom lua-prefix-key "\C-c"
  "Prefix for all lua-mode commands."
  :type 'string
  :group 'lua
  :set 'lua--customize-set-prefix-key
  :get '(lambda (sym)
          (let ((val (eval sym))) (if val (single-key-description (eval sym)) ""))))

(defvar lua-mode-menu (make-sparse-keymap "Lua")
  "Keymap for lua-mode's menu.")

(defvar lua-prefix-mode-map
  (eval-when-compile
    (let ((result-map (make-sparse-keymap)))
      (mapc (lambda (key_defn)
              (define-key result-map (read-kbd-macro (car key_defn)) (cdr key_defn)))
            '(("C-l" . lua-send-buffer)
              ("C-f" . lua-search-documentation)))
      result-map))
  "Keymap that is used to define keys accessible by `lua-prefix-key'.

If the latter is nil, the keymap translates into `lua-mode-map' verbatim.")

(defvar lua--electric-indent-chars
  (mapcar #'string-to-char '("}" "]" ")")))


(defvar lua-mode-map
  (let ((result-map (make-sparse-keymap))
        prefix-key)
    (unless (boundp 'electric-indent-chars)
      (mapc (lambda (electric-char)
              (define-key result-map
                (read-kbd-macro
                 (char-to-string electric-char))
                #'lua-electric-match))
            lua--electric-indent-chars))
    (define-key result-map [menu-bar lua-mode] (cons "Lua" lua-mode-menu))

    ;; FIXME: see if the declared logic actually works
    ;; handle prefix-keyed bindings:
    ;; * if no prefix, set prefix-map as parent, i.e.
    ;;      if key is not defined look it up in prefix-map
    ;; * if prefix is set, bind the prefix-map to that key
    (if (boundp 'lua-prefix-key)
        (define-key result-map (vector lua-prefix-key) lua-prefix-mode-map)
      (set-keymap-parent result-map lua-prefix-mode-map))
    result-map)
  "Keymap used in lua-mode buffers.")

(defvar lua-electric-flag t
  "If t, electric actions (like automatic reindentation) will happen when an electric
 key like `{' is pressed")
(make-variable-buffer-local 'lua-electric-flag)

(defcustom lua-prompt-regexp "[^\n]*\\(>[\t ]+\\)+$"
  "Regexp which matches the Lua program's prompt."
  :type  'regexp
  :group 'lua)

(defcustom lua-traceback-line-re
  ;; This regexp skips prompt and meaningless "stdin:N:" prefix when looking
  ;; for actual file-line locations.
  "^\\(?:[\t ]*\\|.*>[\t ]+\\)\\(?:[^\n\t ]+:[0-9]+:[\t ]*\\)*\\(?:\\([^\n\t ]+\\):\\([0-9]+\\):\\)"
  "Regular expression that describes tracebacks and errors."
  :type 'regexp
  :group 'lua)

(defvar lua--repl-buffer-p nil
  "Buffer-local flag saying if this is a Lua REPL buffer.")
(make-variable-buffer-local 'lua--repl-buffer-p)


(defadvice compilation-find-file (around lua--repl-find-file
                                         (marker filename directory &rest formats)
                                         activate)
  "Return Lua REPL buffer when looking for \"stdin\" file in it."
  (if (and
       lua--repl-buffer-p
       (string-equal filename "stdin")
       ;; NOTE: this doesn't traverse `compilation-search-path' when
       ;; looking for filename.
       (not (file-exists-p (expand-file-name
			    filename
			    (when directory (expand-file-name directory))))))
      (setq ad-return-value (current-buffer))
    ad-do-it))


(defadvice compilation-goto-locus (around lua--repl-goto-locus
                                          (msg mk end-mk)
                                          activate)
  "When message points to Lua REPL buffer, go to the message itself.
Usually, stdin:XX line number points to nowhere."
  (let ((errmsg-buf (marker-buffer msg))
        (error-buf (marker-buffer mk)))
    (if (and (with-current-buffer errmsg-buf lua--repl-buffer-p)
             (eq error-buf errmsg-buf))
        (progn
          (compilation-set-window (display-buffer (marker-buffer msg)) msg)
          (goto-char msg))
      ad-do-it)))


(defcustom lua-indent-string-contents nil
  "If non-nil, contents of multiline string will be indented.
Otherwise leading amount of whitespace on each line is preserved."
  :group 'lua
  :type 'boolean)

(defcustom lua-jump-on-traceback t
  "*Jump to innermost traceback location in *lua* buffer.  When this
variable is non-nil and a traceback occurs when running Lua code in a
process, jump immediately to the source code of the innermost
traceback location."
  :type 'boolean
  :group 'lua)

(defcustom lua-mode-hook nil
  "Hooks called when Lua mode fires up."
  :type 'hook
  :group 'lua)

(defvar lua-region-start (make-marker)
  "Start of special region for Lua communication.")

(defvar lua-region-end (make-marker)
  "End of special region for Lua communication.")

(defvar lua-emacs-menu
  '(["Restart With Whole File" lua-restart-with-whole-file t]
    ["Kill Process" lua-kill-process t]
    ["Hide Process Buffer" lua-hide-process-buffer t]
    ["Show Process Buffer" lua-show-process-buffer t]
    ["Beginning Of Proc" lua-beginning-of-proc t]
    ["End Of Proc" lua-end-of-proc t]
    ["Set Lua-Region Start" lua-set-lua-region-start t]
    ["Set Lua-Region End" lua-set-lua-region-end t]
    ["Send Lua-Region" lua-send-lua-region t]
    ["Send Current Line" lua-send-current-line t]
    ["Send Region" lua-send-region t]
    ["Send Proc" lua-send-proc t]
    ["Send Buffer" lua-send-buffer t]
    ["Search Documentation" lua-search-documentation t])
  "Emacs menu for Lua mode.")

;; the whole defconst is inside eval-when-compile, because it's later referenced
;; inside another eval-and-compile block
(eval-and-compile
  (defconst
    lua--builtins
    (let*
        ((modules
          '("_G" "_VERSION" "assert" "collectgarbage" "dofile" "error" "getfenv"
            "getmetatable" "ipairs" "load" "loadfile" "loadstring" "module"
            "next" "pairs" "pcall" "print" "rawequal" "rawget" "rawlen" "rawset"
            "require" "select" "setfenv" "setmetatable" "tonumber" "tostring"
            "type" "unpack" "xpcall" "self"
            ("bit32" . ("arshift" "band" "bnot" "bor" "btest" "bxor" "extract"
                        "lrotate" "lshift" "replace" "rrotate" "rshift"))
            ("coroutine" . ("create" "isyieldable" "resume" "running" "status"
                            "wrap" "yield"))
            ("debug" . ("debug" "getfenv" "gethook" "getinfo" "getlocal"
                        "getmetatable" "getregistry" "getupvalue" "getuservalue"
                        "setfenv" "sethook" "setlocal" "setmetatable"
                        "setupvalue" "setuservalue" "traceback" "upvalueid"
                        "upvaluejoin"))
            ("io" . ("close" "flush" "input" "lines" "open" "output" "popen"
                     "read" "stderr" "stdin" "stdout" "tmpfile" "type" "write"))
            ("math" . ("abs" "acos" "asin" "atan" "atan2" "ceil" "cos" "cosh"
                       "deg" "exp" "floor" "fmod" "frexp" "huge" "ldexp" "log"
                       "log10" "max" "maxinteger" "min" "mininteger" "modf" "pi"
                       "pow" "rad" "random" "randomseed" "sin" "sinh" "sqrt"
                       "tan" "tanh" "tointeger" "type" "ult"))
            ("os" . ("clock" "date" "difftime" "execute" "exit" "getenv"
                     "remove"  "rename" "setlocale" "time" "tmpname"))
            ("package" . ("config" "cpath" "loaded" "loaders" "loadlib" "path"
                          "preload" "searchers" "searchpath" "seeall"))
            ("string" . ("byte" "char" "dump" "find" "format" "gmatch" "gsub"
                         "len" "lower" "match" "pack" "packsize" "rep" "reverse"
                         "sub" "unpack" "upper"))
            ("table" . ("concat" "insert" "maxn" "move" "pack" "remove" "sort"
                        "unpack"))
            ("utf8" . ("char" "charpattern" "codepoint" "codes" "len"
                       "offset")))))

      (cl-labels
	  ((module-name-re (x)
			   (concat "\\(?1:\\_<"
				   (if (listp x) (car x) x)
				   "\\_>\\)"))
	   (module-members-re (x) (if (listp x)
				      (concat "\\(?:[ \t]*\\.[ \t]*"
					      "\\_<\\(?2:"
					      (regexp-opt (cdr x))
					      "\\)\\_>\\)?")
				    "")))

	(concat
	 ;; common prefix:
	 ;; - beginning-of-line
	 ;; - or neither of [ '.', ':' ] to exclude "foo.string.rep"
	 ;; - or concatenation operator ".."
	 "\\(?:^\\|[^:. \t]\\|[.][.]\\)"
	 ;; optional whitespace
	 "[ \t]*"
	 "\\(?:"
	 ;; any of modules/functions
	 (mapconcat (lambda (x) (concat (module-name-re x)
					(module-members-re x)))
		    modules
		    "\\|")
	 "\\)"))))

  "A regexp that matches Lua builtin functions & variables.

This is a compilation of 5.1, 5.2 and 5.3 builtins taken from the
index of respective Lua reference manuals.")

(eval-and-compile
  (defun lua-make-delimited-matcher (elt-regexp sep-regexp end-regexp)
    "Construct matcher function for `font-lock-keywords' to match a sequence.

It's supposed to match sequences with following EBNF:

ELT-REGEXP { SEP-REGEXP ELT-REGEXP } END-REGEXP

The sequence is parsed one token at a time.  If non-nil is
returned, `match-data' will have one or more of the following
groups set according to next matched token:

1. matched element token
2. unmatched garbage characters
3. misplaced token (i.e. SEP-REGEXP when ELT-REGEXP is expected)
4. matched separator token
5. matched end token

Blanks & comments between tokens are silently skipped.
Groups 6-9 can be used in any of argument regexps."
    (lexical-let*
        ((delimited-matcher-re-template
          "\\=\\(?2:.*?\\)\\(?:\\(?%s:\\(?4:%s\\)\\|\\(?5:%s\\)\\)\\|\\(?%s:\\(?1:%s\\)\\)\\)")
         ;; There's some magic to this regexp. It works as follows:
         ;;
         ;; A. start at (point)
         ;; B. non-greedy match of garbage-characters (?2:)
         ;; C. try matching separator (?4:) or end-token (?5:)
         ;; D. try matching element (?1:)
         ;;
         ;; Simple, but there's a trick: pt.C and pt.D are embraced by one more
         ;; group whose purpose is determined only after the template is
         ;; formatted (?%s:):
         ;;
         ;; - if element is expected, then D's parent group becomes "shy" and C's
         ;;   parent becomes group 3 (aka misplaced token), so if D matches when
         ;;   an element is expected, it'll be marked with warning face.
         ;;
         ;; - if separator-or-end-token is expected, then it's the opposite:
         ;;   C's parent becomes shy and D's will be matched as misplaced token.
         (elt-expected-re (format delimited-matcher-re-template
                                  3 sep-regexp end-regexp "" elt-regexp))
         (sep-or-end-expected-re (format delimited-matcher-re-template
                                         "" sep-regexp end-regexp 3 elt-regexp)))

      (lambda (end)
        (let* ((prev-elt-p (match-beginning 1))
               (prev-sep-p (match-beginning 4))
               (prev-end-p (match-beginning 5))

               (regexp (if prev-elt-p sep-or-end-expected-re elt-expected-re))
               (comment-start (lua-comment-start-pos (syntax-ppss)))
               (parse-stop end))

          ;; If token starts inside comment, or end-token was encountered, stop.
          (when (and (not comment-start)
                     (not prev-end-p))
            ;; Skip all comments & whitespace. forward-comment doesn't have boundary
            ;; argument, so make sure point isn't beyond parse-stop afterwards.
            (while (and (< (point) end)
                        (forward-comment 1)))
            (goto-char (min (point) parse-stop))

            ;; Reuse comment-start variable to store beginning of comment that is
            ;; placed before line-end-position so as to make sure token search doesn't
            ;; enter that comment.
            (setq comment-start
                  (lua-comment-start-pos
                   (save-excursion
                     (parse-partial-sexp (point) parse-stop
                                         nil nil nil 'stop-inside-comment)))
                  parse-stop (or comment-start parse-stop))

            ;; Now, let's match stuff.  If regular matcher fails, declare a span of
            ;; non-blanks 'garbage', and the next iteration will start from where the
            ;; garbage ends.  If couldn't match any garbage, move point to the end
            ;; and return nil.
            (or (re-search-forward regexp parse-stop t)
                (re-search-forward "\\(?1:\\(?2:[^ \t]+\\)\\)" parse-stop 'skip)
                (prog1 nil (goto-char end)))))))))


(defvar lua-font-lock-keywords
  `(;; highlight the hash-bang line "#!/foo/bar/lua" as comment
    ("^#!.*$" . font-lock-comment-face)

    ;; Builtin constants
    (,(lua-rx (symbol "true" "false" "nil"))
     . font-lock-constant-face)

    ;; Keywords
    (,(lua-rx lua-keyword)
     . font-lock-keyword-face)

    ;; Labels used by the "goto" statement
    ;; Highlights the following syntax:  ::label::
    (,(lua-rx "::" ws lua-name ws "::")
     . font-lock-constant-face)

    ;; Hightlights the name of the label in the "goto" statement like
    ;; "goto label"
    (,(lua-rx (symbol (seq "goto" ws+ (group-n 1 lua-name))))
     (1 font-lock-constant-face))

    ;; Highlight Lua builtin functions and variables
    (,lua--builtins
     (1 font-lock-builtin-face) (2 font-lock-builtin-face nil noerror))

    ("^[ \t]*\\_<for\\_>"
     (,(lua-make-delimited-matcher (lua-rx lua-name) ","
                                   (lua-rx (or (symbol "in") lua-assignment-op)))
      nil nil
      (1 font-lock-variable-name-face nil noerror)
      (2 font-lock-warning-face t noerror)
      (3 font-lock-warning-face t noerror)))

    ;; Handle local variable/function names
    ;;  local blalba, xyzzy =
    ;;        ^^^^^^  ^^^^^
    ;;
    ;;  local function foobar(x,y,z)
    ;;                 ^^^^^^
    ;;  local foobar = function(x,y,z)
    ;;        ^^^^^^
    ("^[ \t]*\\_<local\\_>"
     (0 font-lock-keyword-face)

     ;; (* nonl) at the end is to consume trailing characters or otherwise they
     ;; delimited matcher would attempt to parse them afterwards and wrongly
     ;; highlight parentheses as incorrect variable name characters.
     (,(lua-rx point ws lua-funcheader (* nonl))
      nil nil
      (1 font-lock-function-name-face nil noerror))

     (,(lua-make-delimited-matcher (lua-rx lua-name) ","
                                   (lua-rx lua-assignment-op))
      nil nil
      (1 font-lock-variable-name-face nil noerror)
      (2 font-lock-warning-face t noerror)
      (3 font-lock-warning-face t noerror)))

    (,(lua-rx (or bol ";") ws lua-funcheader)
     (1 font-lock-function-name-face))

    (,(lua-rx (or (group-n 1
                           "@" (symbol "author" "copyright" "field" "release"
                                       "return" "see" "usage" "description"))
                  (seq (group-n 1 "@" (symbol "param" "class" "name")) ws+
                       (group-n 2 lua-name))))
     (1 font-lock-keyword-face t)
     (2 font-lock-variable-name-face t noerror)))

  "Default expressions to highlight in Lua mode.")

(defvar lua-imenu-generic-expression
  `((nil ,(lua-rx (or bol ";") ws (opt (seq (symbol "local") ws)) lua-funcheader) 1))
  "Imenu generic expression for lua-mode.  See `imenu-generic-expression'.")

(defvar lua-sexp-alist '(("then" . "end")
			 ("function" . "end")
			 ("do" . "end")
			 ("repeat" . "until")))

(defvar lua-mode-abbrev-table nil
  "Abbreviation table used in lua-mode buffers.")

(define-abbrev-table 'lua-mode-abbrev-table
  '(("end"    "end"    lua-indent-line :system t)
    ("else"   "else"   lua-indent-line :system t)
    ("elseif" "elseif" lua-indent-line :system t)))

(defvar lua-mode-syntax-table
  (with-syntax-table (copy-syntax-table)
    ;; main comment syntax: begins with "--", ends with "\n"
    (modify-syntax-entry ?- ". 12")
    (modify-syntax-entry ?\n ">")

    ;; main string syntax: bounded by ' or "
    (modify-syntax-entry ?\' "\"")
    (modify-syntax-entry ?\" "\"")

    ;; single-character binary operators: punctuation
    (modify-syntax-entry ?+ ".")
    (modify-syntax-entry ?* ".")
    (modify-syntax-entry ?/ ".")
    (modify-syntax-entry ?^ ".")
    (modify-syntax-entry ?% ".")
    (modify-syntax-entry ?> ".")
    (modify-syntax-entry ?< ".")
    (modify-syntax-entry ?= ".")
    (modify-syntax-entry ?~ ".")

    (syntax-table))
  "`lua-mode' syntax table.")

;;;###autoload
(define-derived-mode lua-mode prog-mode "Lua"
  "Major mode for editing Lua code."
  :abbrev-table lua-mode-abbrev-table
  :syntax-table lua-mode-syntax-table
  :group 'lua
  (setq comint-prompt-regexp lua-prompt-regexp)


  (setq-local font-lock-defaults '(lua-font-lock-keywords ;; keywords
				   nil                    ;; keywords-only
				   nil                    ;; case-fold
				   nil                    ;; syntax-alist
				   nil                    ;; syntax-begin
				   ))

  (setq-local syntax-propertize-function
              'lua--propertize-multiline-bounds)

  (setq-local parse-sexp-lookup-properties   t)
  (setq-local indent-line-function           'lua-indent-line)
  (setq-local beginning-of-defun-function    'lua-beginning-of-proc)
  (setq-local end-of-defun-function          'lua-end-of-proc)
  (setq-local comment-start                  lua-comment-start)
  (setq-local comment-start-skip             lua-comment-start-skip)
  (setq-local comment-use-syntax             t)
  (setq-local fill-paragraph-function        #'lua--fill-paragraph)
  (with-no-warnings
    (setq-local comment-use-global-state     t))
  (setq-local imenu-generic-expression       lua-imenu-generic-expression)
  (when (boundp 'electric-indent-chars)
    ;; If electric-indent-chars is not defined, electric indentation is done
    ;; via `lua-mode-map'.
    (setq-local electric-indent-chars
		(append electric-indent-chars lua--electric-indent-chars)))


  ;; setup menu bar entry (XEmacs style)
  (if (and (featurep 'menubar)
           (boundp 'current-menubar)
           (fboundp 'set-buffer-menubar)
           (fboundp 'add-menu)
           (not (assoc "Lua" current-menubar)))
      (progn
        (set-buffer-menubar (copy-sequence current-menubar))
        (add-menu nil "Lua" lua-emacs-menu)))
  ;; Append Lua menu to popup menu for Emacs.
  (if (boundp 'mode-popup-menu)
      (setq mode-popup-menu
            (cons (concat mode-name " Mode Commands") lua-emacs-menu)))

  ;; hideshow setup
  (unless (assq 'lua-mode hs-special-modes-alist)
    (add-to-list 'hs-special-modes-alist
                 `(lua-mode
                   ,(regexp-opt (mapcar 'car lua-sexp-alist) 'words) ;start
                   ,(regexp-opt (mapcar 'cdr lua-sexp-alist) 'words) ;end
                   nil lua-forward-sexp))))



;;;###autoload
(add-to-list 'auto-mode-alist '("\\.lua\\'" . lua-mode))

;;;###autoload
(add-to-list 'interpreter-mode-alist '("lua" . lua-mode))

(defun lua-electric-match (arg)
  "Insert character and adjust indentation."
  (interactive "P")
  (let (blink-paren-function)
    (self-insert-command (prefix-numeric-value arg)))
  (if lua-electric-flag
      (lua-indent-line))
  (blink-matching-open))

;; private functions

(defun lua--fill-paragraph (&optional justify region)
  ;; Implementation of forward-paragraph for filling.
  ;;
  ;; This function works around a corner case in the following situations:
  ;;
  ;;     <>
  ;;     -- some very long comment ....
  ;;     some_code_right_after_the_comment
  ;;
  ;; If point is at the beginning of the comment line, fill paragraph code
  ;; would have gone for comment-based filling and done the right thing, but it
  ;; does not find a comment at the beginning of the empty line before the
  ;; comment and falls back to text-based filling ignoring comment-start and
  ;; spilling the comment into the code.
  (save-excursion
    (while (and (not (eobp))
                (progn (move-to-left-margin)
                       (looking-at paragraph-separate)))
      (forward-line 1))
    (let ((fill-paragraph-handle-comment t))
      (fill-paragraph justify region))))


(defun lua-prefix-key-update-bindings ()
  (let (old-cons)
    (if (eq lua-prefix-mode-map (keymap-parent lua-mode-map))
        ;; if prefix-map is a parent, delete the parent
        (set-keymap-parent lua-mode-map nil)
      ;; otherwise, look for it among children
      (if (setq old-cons (rassoc lua-prefix-mode-map lua-mode-map))
          (delq old-cons lua-mode-map)))

    (if (null lua-prefix-key)
        (set-keymap-parent lua-mode-map lua-prefix-mode-map)
      (define-key lua-mode-map (vector lua-prefix-key) lua-prefix-mode-map))))

(defun lua-set-prefix-key (new-key-str)
  "Changes `lua-prefix-key' properly and updates keymaps

This function replaces previous prefix-key binding with a new one."
  (interactive "sNew prefix key (empty string means no key): ")
  (lua--customize-set-prefix-key 'lua-prefix-key new-key-str)
  (message "Prefix key set to %S"  (single-key-description lua-prefix-key))
  (lua-prefix-key-update-bindings))

(defun lua-string-p (&optional pos)
  "Returns true if the point is in a string."
  (save-excursion (elt (syntax-ppss pos) 3)))

(defun lua-comment-start-pos (parsing-state)
  "Return position of comment containing current point.

If point is not inside a comment, return nil."
  (and parsing-state (nth 4 parsing-state) (nth 8 parsing-state)))

(defun lua-comment-or-string-p (&optional pos)
  "Returns true if the point is in a comment or string."
  (save-excursion (let ((parse-result (syntax-ppss pos)))
                    (or (elt parse-result 3) (elt parse-result 4)))))

(defun lua-comment-or-string-start-pos (&optional pos)
  "Returns start position of string or comment which contains point.

If point is not inside string or comment, return nil."
  (save-excursion (elt (syntax-ppss pos) 8)))

;; They're propertized as follows:
;; 1. generic-comment
;; 2. generic-string
;; 3. equals signs
(defconst lua-ml-begin-regexp
  "\\(?:\\(?1:-\\)-\\[\\|\\(?2:\\[\\)\\)\\(?3:=*\\)\\[")


(defun lua-try-match-multiline-end (end)
  "Try to match close-bracket for multiline literal around point.

Basically, detect form of close bracket from syntactic
information provided at point and re-search-forward to it."
  (let ((comment-or-string-start-pos (lua-comment-or-string-start-pos)))
    ;; Is there a literal around point?
    (and comment-or-string-start-pos
         ;; It is, check if the literal is a multiline open-bracket
         (save-excursion
           (goto-char comment-or-string-start-pos)
           (looking-at lua-ml-begin-regexp))

         ;; Yes it is, look for it matching close-bracket.  Close-bracket's
         ;; match group is determined by match-group of open-bracket.
         (re-search-forward
          (format "]%s\\(?%s:]\\)"
                  (match-string-no-properties 3)
                  (if (match-beginning 1) 1 2))
          end 'noerror))))


(defun lua-try-match-multiline-begin (limit)
  "Try to match multiline open-brackets.

Find next opening long bracket outside of any string/comment.
If none can be found before reaching LIMIT, return nil."

  (let (last-search-matched)
    (while
        ;; This loop will iterate skipping all multiline-begin tokens that are
        ;; inside strings or comments ending either at EOL or at valid token.
        (and (setq last-search-matched
                   (re-search-forward lua-ml-begin-regexp limit 'noerror))

             ;; Handle triple-hyphen '---[[' situation in which the multiline
             ;; opener should be skipped.
             ;;
             ;; In HYPHEN1-HYPHEN2-BRACKET1-BRACKET2 situation (match-beginning
             ;; 0) points to HYPHEN1, but if there's another hyphen before
             ;; HYPHEN1, standard syntax table will only detect comment-start
             ;; at HYPHEN2.
             ;;
             ;; We could check for comment-start at HYPHEN2, but then we'd have
             ;; to flush syntax-ppss cache to remove the result saying that at
             ;; HYPHEN2 there's no comment or string, because under some
             ;; circumstances that would hide the fact that we put a
             ;; comment-start property at HYPHEN1.
             (or (lua-comment-or-string-start-pos (match-beginning 0))
                 (and (eq ?- (char-after (match-beginning 0)))
                      (eq ?- (char-before (match-beginning 0)))))))

    last-search-matched))

(defun lua-match-multiline-literal-bounds (limit)
  ;; First, close any multiline literal spanning from previous block. This will
  ;; move the point accordingly so as to avoid double traversal.
  (or (lua-try-match-multiline-end limit)
      (lua-try-match-multiline-begin limit)))

(defun lua--propertize-multiline-bounds (start end)
  "Put text properties on beginnings and ends of multiline literals.

Intended to be used as a `syntax-propertize-function'."
  (save-excursion
    (goto-char start)
    (while (lua-match-multiline-literal-bounds end)
      (when (match-beginning 1)
        (put-text-property (match-beginning 1) (match-end 1)
                           'syntax-table (string-to-syntax "!")))
      (when (match-beginning 2)
        (put-text-property (match-beginning 2) (match-end 2)
                           'syntax-table (string-to-syntax "|"))))))


(defun lua-indent-line ()
  "Indent current line for Lua mode.
Return the amount the indentation changed by."
  (let (indent
        (case-fold-search nil)
        ;; save point as a distance to eob - it's invariant w.r.t indentation
        (pos (- (point-max) (point))))
    (back-to-indentation)
    (if (lua-comment-or-string-p)
        (setq indent (lua-calculate-string-or-comment-indentation)) ;; just restore point position
      (setq indent (max 0 (lua-calculate-indentation nil))))

    (when (not (equal indent (current-column)))
      (delete-region (line-beginning-position) (point))
      (indent-to indent))

    ;; If initial point was within line's indentation,
    ;; position after the indentation.  Else stay at same point in text.
    (if (> (- (point-max) pos) (point))
        (goto-char (- (point-max) pos)))

    indent))

(defun lua-calculate-string-or-comment-indentation ()
  "This function should be run when point at (current-indentation) is inside string"
  (if (and (lua-string-p) (not lua-indent-string-contents))
      ;; if inside string and strings aren't to be indented, return current indentation
      (current-indentation)

    ;; At this point, we know that we're inside comment, so make sure
    ;; close-bracket is unindented like a block that starts after
    ;; left-shifter.
    (let ((left-shifter-p (looking-at "\\s *\\(?:--\\)?\\]\\(?1:=*\\)\\]")))
      (save-excursion
        (goto-char (lua-comment-or-string-start-pos))
        (+ (current-indentation)
           (if (and left-shifter-p
                    (looking-at (format "--\\[%s\\["
                                        (match-string-no-properties 1))))
               0
             lua-indent-level))))))

(defun lua-find-regexp (direction regexp &optional limit ignore-p)
  "Searches for a regular expression in the direction specified.
Direction is one of 'forward and 'backward.
By default, matches in comments and strings are ignored, but what to ignore is
configurable by specifying ignore-p. If the regexp is found, returns point
position, nil otherwise.
ignore-p returns true if the match at the current point position should be
ignored, nil otherwise."
  (let ((ignore-func (or ignore-p 'lua-comment-or-string-p))
        (search-func (if (eq direction 'forward)
                         're-search-forward 're-search-backward))
        (case-fold-search nil))
    (catch 'found
      (while (funcall search-func regexp limit t)
        (if (and (not (funcall ignore-func (match-beginning 0)))
                 (not (funcall ignore-func (match-end 0))))
            (throw 'found (point)))))))

(defconst lua-block-regexp
  (eval-when-compile
    (concat
     "\\(\\_<"
     (regexp-opt '("do" "function" "repeat" "then"
                   "else" "elseif" "end" "until") t)
     "\\_>\\)\\|"
     (regexp-opt '("{" "(" "[" "]" ")" "}") t))))

(defconst lua-block-token-alist
  '(("do"       "\\_<end\\_>"   "\\_<for\\|while\\_>"                       middle-or-open)
    ("function" "\\_<end\\_>"   nil                                       open)
    ("repeat"   "\\_<until\\_>" nil                                       open)
    ("then"     "\\_<\\(e\\(lse\\(if\\)?\\|nd\\)\\)\\_>" "\\_<\\(else\\)?if\\_>" middle)
    ("{"        "}"           nil                                       open)
    ("["        "]"           nil                                       open)
    ("("        ")"           nil                                       open)
    ("if"       "\\_<then\\_>"  nil                                       open)
    ("for"      "\\_<do\\_>"    nil                                       open)
    ("while"    "\\_<do\\_>"    nil                                       open)
    ("else"     "\\_<end\\_>"   "\\_<then\\_>"                              middle)
    ("elseif"   "\\_<then\\_>"  "\\_<then\\_>"                              middle)
    ("end"      nil           "\\_<\\(do\\|function\\|then\\|else\\)\\_>" close)
    ("until"    nil           "\\_<repeat\\_>"                            close)
    ("}"        nil           "{"                                       close)
    ("]"        nil           "\\["                                     close)
    (")"        nil           "("                                       close))
  "This is a list of block token information blocks.
Each token information entry is of the form:
  KEYWORD FORWARD-MATCH-REGEXP BACKWARDS-MATCH-REGEXP TOKEN-TYPE
KEYWORD is the token.
FORWARD-MATCH-REGEXP is a regexp that matches all possble tokens when going forward.
BACKWARDS-MATCH-REGEXP is a regexp that matches all possble tokens when going backwards.
TOKEN-TYPE determines where the token occurs on a statement. open indicates that the token appears at start, close indicates that it appears at end, middle indicates that it is a middle type token, and middle-or-open indicates that it can appear both as a middle or an open type.")

(defconst lua-indentation-modifier-regexp
  ;; The absence of else is deliberate, since it does not modify the
  ;; indentation level per se. It only may cause the line, in which the
  ;; else is, to be shifted to the left.
  (concat
   "\\(\\_<"
   (regexp-opt '("do" "function" "repeat" "then" "if" "else" "elseif" "for" "while") t)
   "\\_>\\|"
   (regexp-opt '("{" "(" "["))
   "\\)\\|\\(\\_<"
   (regexp-opt '("end" "until") t)
   "\\_>\\|"
   (regexp-opt '("]" ")" "}"))
   "\\)")
  )

(defun lua-get-block-token-info (token)
  "Returns the block token info entry for TOKEN from lua-block-token-alist"
  (assoc token lua-block-token-alist))

(defun lua-get-token-match-re (token-info direction)
  "Returns the relevant match regexp from token info"
  (cond
   ((eq direction 'forward) (cadr token-info))
   ((eq direction 'backward) (caddr token-info))
   (t nil)))

(defun lua-get-token-type (token-info)
  "Returns the relevant match regexp from token info"
  (cadddr token-info))

(defun lua-backwards-to-block-begin-or-end ()
  "Move backwards to nearest block begin or end.  Returns nil if not successful."
  (interactive)
  (lua-find-regexp 'backward lua-block-regexp))

(defun lua-find-matching-token-word (token &optional direction)
  "Find matching open- or close-token for TOKEN in DIRECTION.
Point has to be exactly at the beginning of TOKEN, e.g. with | being point

  {{ }|}  -- (lua-find-matching-token-word \"}\" 'backward) will return
          -- the first {
  {{ |}}  -- (lua-find-matching-token-word \"}\" 'backward) will find
          -- the second {.

DIRECTION has to be either 'forward or 'backward."
  (let* ((token-info (lua-get-block-token-info token))
         (match-type (lua-get-token-type token-info))
         ;; If we are on a middle token, go backwards. If it is a middle or open,
         ;; go forwards
         (search-direction (or direction
                               (if (or (eq match-type 'open)
                                       (eq match-type 'middle-or-open))
                                   'forward
                                 'backward)
                               'backward))
         (match (lua-get-token-match-re token-info search-direction))
         maybe-found-pos)
    ;; if we are searching forward from the token at the current point
    ;; (i.e. for a closing token), need to step one character forward
    ;; first, or the regexp will match the opening token.
    (if (eq search-direction 'forward) (forward-char 1))
    (catch 'found
      ;; If we are attempting to find a matching token for a terminating token
      ;; (i.e. a token that starts a statement when searching back, or a token
      ;; that ends a statement when searching forward), then we don't need to look
      ;; any further.
      (if (or (and (eq search-direction 'forward)
                   (eq match-type 'close))
              (and (eq search-direction 'backward)
                   (eq match-type 'open)))
          (throw 'found nil))
      (while (lua-find-regexp search-direction lua-indentation-modifier-regexp)
        ;; have we found a valid matching token?
        (let ((found-token (match-string 0))
              (found-pos (match-beginning 0)))
          (let ((found-type (lua-get-token-type
                             (lua-get-block-token-info found-token))))
            (if (not (and match (string-match match found-token)))
                ;; no - then there is a nested block. If we were looking for
                ;; a block begin token, found-token must be a block end
                ;; token; likewise, if we were looking for a block end token,
                ;; found-token must be a block begin token, otherwise there
                ;; is a grammatical error in the code.
                (if (not (and
                          (or (eq match-type 'middle)
                              (eq found-type 'middle)
                              (eq match-type 'middle-or-open)
                              (eq found-type 'middle-or-open)
                              (eq match-type found-type))
                          (goto-char found-pos)
                          (lua-find-matching-token-word found-token
                                                        search-direction)))
                    (when maybe-found-pos
                      (goto-char maybe-found-pos)
                      (throw 'found maybe-found-pos)))
              ;; yes.
              ;; if it is a not a middle kind, report the location
              (when (not (or (eq found-type 'middle)
                             (eq found-type 'middle-or-open)))
                (throw 'found found-pos))
              ;; if it is a middle-or-open type, record location, but keep searching.
              ;; If we fail to complete the search, we'll report the location
              (when (eq found-type 'middle-or-open)
                (setq maybe-found-pos found-pos))
              ;; Cannot use tail recursion. too much nesting on long chains of
              ;; if/elseif. Will reset variables instead.
              (setq token found-token)
              (setq token-info (lua-get-block-token-info token))
              (setq match (lua-get-token-match-re token-info search-direction))
              (setq match-type (lua-get-token-type token-info))))))
      maybe-found-pos)))

(defun lua-goto-matching-block-token (&optional parse-start direction)
  "Find block begion/end token matching the one at the point.
This function moves the point to the token that matches the one
at the current point. Returns the point position of the first character of
the matching token if successful, nil otherwise."
  (if parse-start (goto-char parse-start))
  (let ((case-fold-search nil))
    (if (looking-at lua-indentation-modifier-regexp)
        (let ((position (lua-find-matching-token-word (match-string 0)
                                                      direction)))
          (and position
               (goto-char position))))))

(defun lua-goto-matching-block (&optional noreport)
  "Go to the keyword balancing the one under the point.
If the point is on a keyword/brace that starts a block, go to the
matching keyword that ends the block, and vice versa."
  (interactive)
  ;; search backward to the beginning of the keyword if necessary
  (if (eq (char-syntax (following-char)) ?w)
      (re-search-backward "\\_<" nil t))
  (let ((position (lua-goto-matching-block-token)))
    (if (and (not position)
             (not noreport))
        (error "Not on a block control keyword or brace")
      position)))

(defun lua-forward-line-skip-blanks (&optional back)
  "Move 1 line forward (back if BACK is non-nil) skipping blank lines.

Moves point 1 line forward (or backward) skipping lines that contain
no Lua code besides comments. The point is put to the beginning of
the line.

Returns final value of point as integer or nil if operation failed."
  (catch 'found
    (while t
      (unless (eql (forward-line (if back -1 1)) 0)    ;; 0 means success
        (throw 'found nil))
      (unless (or (looking-at "\\s *\\(--.*\\)?$")
                  (lua-comment-or-string-p))
        (throw 'found (point))))))

(eval-when-compile
  (defconst lua-operator-class
    "-+*/^.=<>~:&|"))

(defconst lua-cont-eol-regexp
  (eval-when-compile
    (concat
     "\\(\\_<"
     (regexp-opt '("and" "or" "not" "in" "for" "while"
                   "local" "function" "if" "until" "elseif" "return")
                 t)
     "\\_>\\|"
     "\\(^\\|[^" lua-operator-class "]\\)"
     (regexp-opt '("+" "-" "*" "/" "%" "^" ".." "=="
                   "=" "<" ">" "<=" ">=" "~=" "." ":"
                   "&" "|" "~" ">>" "<<" "~")
                 t)
     "\\)"
     "\\s *\\="))
  "Regexp that matches the ending of a line that needs continuation

This regexp starts from eol and looks for a binary operator or an unclosed
block intro (i.e. 'for' without 'do' or 'if' without 'then') followed by
an optional whitespace till the end of the line.")

(defconst lua-cont-bol-regexp
  (eval-when-compile
    (concat
     "\\=\\s *"
     "\\(\\_<"
     (regexp-opt '("and" "or" "not") t)
     "\\_>\\|"
     (regexp-opt '("+" "-" "*" "/" "%" "^" ".." "=="
                   "=" "<" ">" "<=" ">=" "~=" "." ":"
                   "&" "|" "~" ">>" "<<" "~")
                 t)
     "\\($\\|[^" lua-operator-class "]\\)"
     "\\)"))
  "Regexp that matches a line that continues previous one

This regexp means, starting from point there is an optional whitespace followed
by Lua binary operator. Lua is very liberal when it comes to continuation line,
so we're safe to assume that every line that starts with a binop continues
previous one even though it looked like an end-of-statement.")

(defun lua-last-token-continues-p ()
  "Returns true if the last token on this line is a continuation token."
  (let ((line-begin (line-beginning-position))
        (line-end (line-end-position)))
    (save-excursion
      (end-of-line)
      ;; we need to check whether the line ends in a comment and
      ;; skip that one.
      (while (lua-find-regexp 'backward "-" line-begin 'lua-string-p)
        (if (looking-at "--")
            (setq line-end (point))))
      (goto-char line-end)
      (re-search-backward lua-cont-eol-regexp line-begin t))))

(defun lua-first-token-continues-p ()
  "Returns true if the first token on this line is a continuation token."
  (let ((line-end (line-end-position)))
    (save-excursion
      (beginning-of-line)
      ;; if first character of the line is inside string, it's a continuation
      ;; if strings aren't supposed to be indented, `lua-calculate-indentation' won't even let
      ;; the control inside this function
      (re-search-forward lua-cont-bol-regexp line-end t))))

(defconst lua-block-starter-regexp
  (eval-when-compile
    (concat
     "\\(\\_<"
     (regexp-opt '("do" "while" "repeat" "until" "if" "then"
                   "else" "elseif" "end" "for" "local") t)
     "\\_>\\)")))

(defun lua-first-token-starts-block-p ()
  "Returns true if the first token on this line is a block starter token."
  (let ((line-end (line-end-position)))
    (save-excursion
      (beginning-of-line)
      (re-search-forward (concat "\\s *" lua-block-starter-regexp) line-end t))))

(defun lua-is-continuing-statement-p (&optional parse-start)
  "Return non-nil if the line continues a statement.
More specifically, return the point in the line that is continued.
The criteria for a continuing statement are:

* the last token of the previous line is a continuing op,
  OR the first token of the current line is a continuing op

"
  (let ((prev-line nil))
    (save-excursion
      (if parse-start (goto-char parse-start))
      (save-excursion (setq prev-line (lua-forward-line-skip-blanks 'back)))
      (and prev-line
           (not (lua-first-token-starts-block-p))
           (or (lua-first-token-continues-p)
               (and (goto-char prev-line)
                    ;; check last token of previous nonblank line
                    (lua-last-token-continues-p)))))))

(defun lua-make-indentation-info-pair (found-token found-pos)
  "This is a helper function to lua-calculate-indentation-info. Don't
use standalone."
  (cond
   ;; function is a bit tricky to indent right. They can appear in a lot ot
   ;; different contexts. Until I find a shortcut, I'll leave it with a simple
   ;; relative indentation.
   ;; The special cases are for indenting according to the location of the
   ;; function. i.e.:
   ;;       (cons 'absolute (+ (current-column) lua-indent-level))
   ;; TODO: Fix this. It causes really ugly indentations for in-line functions.
   ((string-equal found-token "function")
    (cons 'relative lua-indent-level))

   ;; block openers
   ((member found-token (list "{" "(" "["))
    (save-excursion
      (let ((found-bol (line-beginning-position)))
        (forward-comment (point-max))
        ;; If the next token is on this line and it's not a block opener,
        ;; the next line should align to that token.
        (if (and (zerop (count-lines found-bol (line-beginning-position)))
                 (not (looking-at lua-indentation-modifier-regexp)))
            (cons 'absolute (current-column))
          (cons 'relative lua-indent-level)))))

   ;; These are not really block starters. They should not add to indentation.
   ;; The corresponding "then" and "do" handle the indentation.
   ((member found-token (list "if" "for" "while"))
    (cons 'relative 0))
   ;; closing tokens follow: These are usually taken care of by
   ;; lua-calculate-indentation-override.
   ;; elseif is a bit of a hack. It is not handled separately, but it needs to
   ;; nullify a previous then if on the same line.
   ((member found-token (list "until" "elseif"))
    (save-excursion
      (let ((line (line-number-at-pos)))
        (if (and (lua-goto-matching-block-token found-pos 'backward)
                 (= line (line-number-at-pos)))
            (cons 'remove-matching 0)
          (cons 'relative 0)))))

   ;; else is a special case; if its matching block token is on the same line,
   ;; instead of removing the matching token, it has to replace it, so that
   ;; either the next line will be indented correctly, or the end on the same
   ;; line will remove the effect of the else.
   ((string-equal found-token "else")
    (save-excursion
      (let ((line (line-number-at-pos)))
	(if (and (lua-goto-matching-block-token found-pos 'backward)
		 (= line (line-number-at-pos)))
	    (cons 'replace-matching (cons 'relative lua-indent-level))
	  (cons 'relative lua-indent-level)))))

   ;; Block closers. If they are on the same line as their openers, they simply
   ;; eat up the matching indentation modifier. Otherwise, they pull
   ;; indentation back to the matching block opener.
   ((member found-token (list ")" "}" "]" "end"))
    (save-excursion
      (let ((line (line-number-at-pos)))
        (lua-goto-matching-block-token found-pos 'backward)
        (if (/= line (line-number-at-pos))
            (lua-calculate-indentation-info (point))
          (cons 'remove-matching 0)))))

   ;; Everything else. This is from the original code: If opening a block
   ;; (match-data 1 exists), then push indentation one level up, if it is
   ;; closing a block, pull it one level down.
   ('other-indentation-modifier
    (cons 'relative (if (nth 2 (match-data))
                        ;; beginning of a block matched
                        lua-indent-level
                      ;; end of a block matched
                      (- lua-indent-level))))))

(defun  lua-add-indentation-info-pair (pair info)
  "Add the given indentation info pair to the list of indentation information.
This function has special case handling for two tokens: remove-matching,
and replace-matching. These two tokens are cleanup tokens that remove or
alter the effect of a previously recorded indentation info.

When a remove-matching token is encountered, the last recorded info, i.e.
the car of the list is removed. This is used to roll-back an indentation of a
block opening statement when it is closed.

When a replace-matching token is seen, the last recorded info is removed,
and the cdr of the replace-matching info is added in its place. This is used
when a middle-of the block (the only case is 'else') is seen on the same line
the block is opened."
  (cond
   ( (eq 'remove-matching (car pair))
					; Remove head of list
     (cdr info))
   ( (eq 'replace-matching (car pair))
					; remove head of list, and add the cdr of pair instead
     (cons (cdr pair) (cdr info)))
   ( (listp (cdr-safe pair))
     (nconc pair info))
   ( t
					; Just add the pair
     (cons pair info))))

(defun lua-calculate-indentation-info-1 (indentation-info bound)
  "Helper function for `lua-calculate-indentation-info'.

Return list of indentation modifiers from point to BOUND."
  (while (lua-find-regexp 'forward lua-indentation-modifier-regexp
                          bound)
    (let ((found-token (match-string 0))
          (found-pos (match-beginning 0))
          (found-end (match-end 0))
          (data (match-data)))
      (setq indentation-info
            (lua-add-indentation-info-pair
             (lua-make-indentation-info-pair found-token found-pos)
             indentation-info))))
  indentation-info)


(defun lua-calculate-indentation-info (&optional parse-end)
  "For each block token on the line, computes how it affects the indentation.
The effect of each token can be either a shift relative to the current
indentation level, or indentation to some absolute column. This information
is collected in a list of indentation info pairs, which denote absolute
and relative each, and the shift/column to indent to."
  (let ((combined-line-end (line-end-position))
        indentation-info)

    (while (lua-is-continuing-statement-p)
      (lua-forward-line-skip-blanks 'back))

    ;; calculate indentation modifiers for the line itself
    (setq indentation-info (list (cons 'absolute (current-indentation))))

    (back-to-indentation)
    (setq indentation-info
          (lua-calculate-indentation-info-1
           indentation-info (min parse-end (line-end-position))))

    ;; and do the following for each continuation line before PARSE-END
    (while (and (eql (forward-line 1) 0)
                (<= (point) parse-end))

      ;; handle continuation lines:
      (if (lua-is-continuing-statement-p)
          ;; if it's the first continuation line, add one level
          (unless (eq (car (car indentation-info)) 'continued-line)
            (push (cons 'continued-line lua-indent-level) indentation-info))

        ;; if it's the first non-continued line, subtract one level
        (when (eq (car (car indentation-info)) 'continued-line)
          (pop indentation-info)))

      ;; add modifiers found in this continuation line
      (setq indentation-info
            (lua-calculate-indentation-info-1
             indentation-info (min parse-end (line-end-position)))))

    indentation-info))


(defun lua-accumulate-indentation-info (info)
  "Accumulates the indentation information previously calculated by
lua-calculate-indentation-info. Returns either the relative indentation
shift, or the absolute column to indent to."
  (let ((info-list (reverse info))
        (type 'relative)
        (accu 0))
    (mapc (lambda (x)
            (setq accu (if (eq 'absolute (car x))
                           (progn (setq type 'absolute)
                                  (cdr x))
                         (+ accu (cdr x)))))
          info-list)
    (cons type accu)))

(defun lua-calculate-indentation-block-modifier (&optional parse-end)
  "Return amount by which this line modifies the indentation.
Beginnings of blocks add lua-indent-level once each, and endings
of blocks subtract lua-indent-level once each. This function is used
to determine how the indentation of the following line relates to this
one."
  (let (indentation-info)
    (save-excursion
      ;; First go back to the line that starts it all
      ;; lua-calculate-indentation-info will scan through the whole thing
      (let ((case-fold-search nil))
        (setq indentation-info
              (lua-accumulate-indentation-info
               (lua-calculate-indentation-info parse-end)))))

    (if (eq (car indentation-info) 'absolute)
        (- (cdr indentation-info) (current-indentation))
      (cdr indentation-info))))


(eval-when-compile
  (defconst lua--function-name-rx
    '(seq symbol-start
          (+ (any alnum "_"))
          (* "." (+ (any alnum "_")))
          (? ":" (+ (any alnum "_")))
          symbol-end)
    "Lua function name regexp in `rx'-SEXP format."))


(defconst lua--left-shifter-regexp
  (eval-when-compile
    (rx
     ;; This regexp should answer the following questions:
     ;; 1. is there a left shifter regexp on that line?
     ;; 2. where does block-open token of that left shifter reside?
     (or (seq (group-n 1 symbol-start "local" (+ blank)) "function" symbol-end)

         (seq (group-n 1 (eval lua--function-name-rx) (* blank)) (any "{("))
         (seq (group-n 1 (or
                          ;; assignment statement prefix
                          (seq (* nonl) (not (any "<=>~")) "=" (* blank))
                          ;; return statement prefix
                          (seq word-start "return" word-end (* blank))))
              ;; right hand side
              (or "{"
                  "function"
                  (seq (group-n 1 (eval lua--function-name-rx) (* blank))
                       (any "({")))))))

  "Regular expression that matches left-shifter expression.

Left-shifter expression is defined as follows.  If a block
follows a left-shifter expression, its contents & block-close
token should be indented relative to left-shifter expression
indentation rather then to block-open token.

For example:
   -- 'local a = ' is a left-shifter expression
   -- 'function' is a block-open token
   local a = function()
      -- block contents is indented relative to left-shifter
      foobarbaz()
   -- block-end token is unindented to left-shifter indentation
   end

The following left-shifter expressions are currently handled:
1. local function definition with function block, begin-end
2. function call with arguments block, () or {}
3. assignment/return statement with
   - table constructor block, {}
   - function call arguments block, () or {} block
   - function expression a.k.a. lambda, begin-end block.")


(defun lua-point-is-after-left-shifter-p ()
  "Check if point is right after a left-shifter expression.

See `lua--left-shifter-regexp' for description & example of
left-shifter expression. "
  (save-excursion
    (let ((old-point (point)))
      (back-to-indentation)
      (and
       (/= (point) old-point)
       (looking-at lua--left-shifter-regexp)
       (= old-point (match-end 1))))))



(defun lua-calculate-indentation-override (&optional parse-start)
  "Return overriding indentation amount for special cases.

If there's a sequence of block-close tokens starting at the
beginning of the line, calculate indentation according to the
line containing block-open token for the last block-close token
in the sequence.

If not, return nil."
  (let (case-fold-search token-info block-token-pos)
    (save-excursion
      (if parse-start (goto-char parse-start))

      (back-to-indentation)
      (unless (lua-comment-or-string-p)
        (while
            (and (looking-at lua-indentation-modifier-regexp)
                 (setq token-info (lua-get-block-token-info (match-string 0)))
                 (not (eq 'open (lua-get-token-type token-info))))
          (setq block-token-pos (match-beginning 0))
          (goto-char (match-end 0))
          (skip-syntax-forward " " (line-end-position)))

        (when (lua-goto-matching-block-token block-token-pos 'backward)
          ;; Exception cases: when the start of the line is an assignment,
          ;; go to the start of the assignment instead of the matching item
          (if (lua-point-is-after-left-shifter-p)
              (current-indentation)
            (current-column)))))))

(defun lua-calculate-indentation (&optional parse-start)
  "Return appropriate indentation for current line as Lua code."
  (save-excursion
    (let ((continuing-p (lua-is-continuing-statement-p))
          (cur-line-begin-pos (line-beginning-position)))
      (or
       ;; when calculating indentation, do the following:
       ;; 1. check, if the line starts with indentation-modifier (open/close brace)
       ;;    and if it should be indented/unindented in special way
       (lua-calculate-indentation-override)

       (when (lua-forward-line-skip-blanks 'back)
         ;; the order of function calls here is important. block modifier
         ;; call may change the point to another line
         (let* ((modifier
                 (lua-calculate-indentation-block-modifier cur-line-begin-pos)))
           (+ (current-indentation) modifier)))

       ;; 4. if there's no previous line, indentation is 0
       0))))

(defvar lua--beginning-of-defun-re
  (lua-rx-to-string '(: bol (? (symbol "local") ws+) lua-funcheader))
  "Lua top level (matches only at the beginning of line) function header regex.")


(defun lua-beginning-of-proc (&optional arg)
  "Move backward to the beginning of a Lua proc (or similar).

With argument, do it that many times.  Negative arg -N
means move forward to Nth following beginning of proc.

Returns t unless search stops due to beginning or end of buffer."
  (interactive "P")
  (or arg (setq arg 1))

  (while (and (> arg 0)
              (re-search-backward lua--beginning-of-defun-re nil t))
    (setq arg (1- arg)))

  (while (and (< arg 0)
              (re-search-forward lua--beginning-of-defun-re nil t))
    (beginning-of-line)
    (setq arg (1+ arg)))

  (zerop arg))

(defun lua-end-of-proc (&optional arg)
  "Move forward to next end of Lua proc (or similar).
With argument, do it that many times.  Negative argument -N means move
back to Nth preceding end of proc.

This function just searches for a `end' at the beginning of a line."
  (interactive "P")
  (or arg
      (setq arg 1))
  (let ((found nil)
        (ret t))
    (if (and (< arg 0)
             (not (bolp))
             (save-excursion
               (beginning-of-line)
               (eq (following-char) ?})))
        (forward-char -1))
    (while (> arg 0)
      (if (re-search-forward "^end" nil t)
          (setq arg (1- arg)
                found t)
        (setq ret nil
              arg 0)))
    (while (< arg 0)
      (if (re-search-backward "^end" nil t)
          (setq arg (1+ arg)
                found t)
        (setq ret nil
              arg 0)))
    (if found
        (progn
          (beginning-of-line)
          (forward-line)))
    ret))

(defvar lua-process-init-code
  (mapconcat
   'identity
   '("local loadstring = loadstring or load"
     "function luamode_loadstring(str, displayname, lineoffset)"
     "  if lineoffset > 1 then"
     "    str = string.rep('\\n', lineoffset - 1) .. str"
     "  end"
     ""
     "  local x, e = loadstring(str, '@'..displayname)"
     "  if e then"
     "    error(e)"
     "  end"
     "  return x()"
     "end")
   " "))

(defun lua-make-lua-string (str)
  "Convert string to Lua literal."
  (save-match-data
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (while (re-search-forward "[\"'\\\t\\\n]" nil t)
        (cond
	 ((string= (match-string 0) "\n")
	  (replace-match "\\\\n"))
	 ((string= (match-string 0) "\t")
	  (replace-match "\\\\t"))
	 (t
          (replace-match "\\\\\\&" t))))
      (concat "'" (buffer-string) "'"))))

;;;###autoload
(defalias 'run-lua #'lua-start-process)

;;;###autoload
(defun lua-start-process (&optional name program startfile &rest switches)
  "Start a Lua process named NAME, running PROGRAM.
PROGRAM defaults to NAME, which defaults to `lua-default-application'.
When called interactively, switch to the process buffer."
  (interactive)
  (or switches
      (setq switches lua-default-command-switches))
  (setq name (or name (if (consp lua-default-application)
                          (car lua-default-application)
                        lua-default-application)))
  (setq program (or program lua-default-application))
  (setq lua-process-buffer (apply 'make-comint name program startfile switches))
  (setq lua-process (get-buffer-process lua-process-buffer))
  (set-process-query-on-exit-flag lua-process nil)
  (with-current-buffer lua-process-buffer
    ;; wait for prompt
    (while (not (lua-prompt-line))
      (accept-process-output (get-buffer-process (current-buffer)))
      (goto-char (point-max)))
    ;; send initialization code
    (lua-send-string lua-process-init-code)

    ;; enable error highlighting in stack traces
    (require 'compile)
    (setq lua--repl-buffer-p t)
    (make-local-variable 'compilation-error-regexp-alist)
    (setq compilation-error-regexp-alist
          (cons (list lua-traceback-line-re 1 2)
                compilation-error-regexp-alist))
    (compilation-shell-minor-mode 1))

  ;; when called interactively, switch to process buffer
  (if (called-interactively-p 'any)
      (switch-to-buffer lua-process-buffer)))

(defun lua-get-create-process ()
  "Return active Lua process creating one if necessary."
  (unless (comint-check-proc lua-process-buffer)
    (lua-start-process))
  lua-process)

(defun lua-kill-process ()
  "Kill Lua process and its buffer."
  (interactive)
  (when (buffer-live-p lua-process-buffer)
    (kill-buffer lua-process-buffer)
    (setq lua-process-buffer nil)))

(defun lua-set-lua-region-start (&optional arg)
  "Set start of region for use with `lua-send-lua-region'."
  (interactive)
  (set-marker lua-region-start (or arg (point))))

(defun lua-set-lua-region-end (&optional arg)
  "Set end of region for use with `lua-send-lua-region'."
  (interactive)
  (set-marker lua-region-end (or arg (point))))

(defun lua-send-string (str)
  "Send STR plus a newline to the Lua process.

If `lua-process' is nil or dead, start a new process first."
  (unless (string-equal (substring str -1) "\n")
    (setq str (concat str "\n")))
  (process-send-string (lua-get-create-process) str))

(defun lua-send-current-line ()
  "Send current line to the Lua process, found in `lua-process'.
If `lua-process' is nil or dead, start a new process first."
  (interactive)
  (lua-send-region (line-beginning-position) (line-end-position)))

(defun lua-send-defun (pos)
  "Send the function definition around point to the Lua process."
  (interactive "d")
  (save-excursion
    (let ((start (if (save-match-data (looking-at "^function[ \t]"))
                     ;; point already at the start of "function".
                     ;; We need to handle this case explicitly since
                     ;; lua-beginning-of-proc will move to the
                     ;; beginning of the _previous_ function.
                     (point)
                   ;; point is not at the beginning of function, move
                   ;; there and bind start to that position
                   (lua-beginning-of-proc)
                   (point)))
          (end (progn (lua-end-of-proc) (point))))

      ;; make sure point is in a function definition before sending to
      ;; the process
      (if (and (>= pos start) (< pos end))
          (lua-send-region start end)
        (error "Not on a function definition")))))

(defun lua-maybe-skip-shebang-line (start)
  "Skip shebang (#!/path/to/interpreter/) line at beginning of buffer.

Return a position that is after Lua-recognized shebang line (1st
character in file must be ?#) if START is at its beginning.
Otherwise, return START."
  (save-restriction
    (widen)
    (if (and (eq start (point-min))
             (eq (char-after start) ?#))
        (save-excursion
          (goto-char start)
          (forward-line)
          (point))
      start)))

(defun lua-send-region (start end)
  (interactive "r")
  (setq start (lua-maybe-skip-shebang-line start))
  (let* ((lineno (line-number-at-pos start))
         (lua-file (or (buffer-file-name) (buffer-name)))
         (region-str (buffer-substring-no-properties start end))
         (command
          ;; Print empty line before executing the code so that the first line
          ;; of output doesn't end up on the same line as current prompt.
          (format "print(''); luamode_loadstring(%s, %s, %s);\n"
                  (lua-make-lua-string region-str)
                  (lua-make-lua-string lua-file)
                  lineno)))
    (lua-send-string command)
    (when lua-always-show (lua-show-process-buffer))))

(defun lua-prompt-line ()
  (save-excursion
    (save-match-data
      (forward-line 0)
      (if (looking-at comint-prompt-regexp)
          (match-end 0)))))

(defun lua-send-lua-region ()
  "Send preset Lua region to Lua process."
  (interactive)
  (unless (and lua-region-start lua-region-end)
    (error "lua-region not set"))
  (lua-send-region lua-region-start lua-region-end))

(defalias 'lua-send-proc 'lua-send-defun)

(defun lua-send-buffer ()
  "Send whole buffer to Lua process."
  (interactive)
  (lua-send-region (point-min) (point-max)))

(defun lua-restart-with-whole-file ()
  "Restart Lua process and send whole file as input."
  (interactive)
  (lua-kill-process)
  (lua-send-buffer))

(defun lua-show-process-buffer ()
  "Make sure `lua-process-buffer' is being displayed.
Create a Lua process if one doesn't already exist."
  (interactive)
  (display-buffer (process-buffer (lua-get-create-process))))


(defun lua-hide-process-buffer ()
  "Delete all windows that display `lua-process-buffer'."
  (interactive)
  (when (buffer-live-p lua-process-buffer)
    (delete-windows-on lua-process-buffer)))

(defun lua-funcname-at-point ()
  "Get current Name { '.' Name } sequence."
  ;; FIXME: copying/modifying syntax table for each call may incur a penalty
  (with-syntax-table (copy-syntax-table)
    (modify-syntax-entry ?. "_")
    (current-word t)))

(defun lua-search-documentation ()
  "Search Lua documentation for the word at the point."
  (interactive)
  (let ((url (concat lua-documentation-url "#pdf-" (lua-funcname-at-point))))
    (funcall lua-documentation-function url)))

(defun lua-toggle-electric-state (&optional arg)
  "Toggle the electric indentation feature.
Optional numeric ARG, if supplied, turns on electric indentation when
positive, turns it off when negative, and just toggles it when zero or
left out."
  (interactive "P")
  (let ((num_arg (prefix-numeric-value arg)))
    (setq lua-electric-flag (cond ((or (null arg)
                                       (zerop num_arg)) (not lua-electric-flag))
                                  ((< num_arg 0) nil)
                                  ((> num_arg 0) t))))
  (message "%S" lua-electric-flag))

(defun lua-forward-sexp (&optional count)
  "Forward to block end"
  (interactive "p")
  ;; negative offsets not supported
  (assert (or (not count) (>= count 0)))
  (save-match-data
    (let* ((count (or count 1))
           (block-start (mapcar 'car lua-sexp-alist))
           (block-end (mapcar 'cdr lua-sexp-alist))
           (block-regex (regexp-opt (append  block-start block-end) 'words))
           current-exp)
      (while (> count 0)
        ;; skip whitespace
        (skip-chars-forward " \t\n")
        (if (looking-at (regexp-opt block-start 'words))
            (let ((keyword (match-string 1)))
              (lua-find-matching-token-word keyword 'forward))
          ;; If the current keyword is not a "begin" keyword, then just
          ;; perform the normal forward-sexp.
          (forward-sexp 1))
        (setq count (1- count))))))


;; menu bar

(define-key lua-mode-menu [restart-with-whole-file]
  '("Restart With Whole File" .  lua-restart-with-whole-file))
(define-key lua-mode-menu [kill-process]
  '("Kill Process" . lua-kill-process))

(define-key lua-mode-menu [hide-process-buffer]
  '("Hide Process Buffer" . lua-hide-process-buffer))
(define-key lua-mode-menu [show-process-buffer]
  '("Show Process Buffer" . lua-show-process-buffer))

(define-key lua-mode-menu [end-of-proc]
  '("End Of Proc" . lua-end-of-proc))
(define-key lua-mode-menu [beginning-of-proc]
  '("Beginning Of Proc" . lua-beginning-of-proc))

(define-key lua-mode-menu [send-lua-region]
  '("Send Lua-Region" . lua-send-lua-region))
(define-key lua-mode-menu [set-lua-region-end]
  '("Set Lua-Region End" . lua-set-lua-region-end))
(define-key lua-mode-menu [set-lua-region-start]
  '("Set Lua-Region Start" . lua-set-lua-region-start))

(define-key lua-mode-menu [send-current-line]
  '("Send Current Line" . lua-send-current-line))
(define-key lua-mode-menu [send-region]
  '("Send Region" . lua-send-region))
(define-key lua-mode-menu [send-proc]
  '("Send Proc" . lua-send-proc))
(define-key lua-mode-menu [send-buffer]
  '("Send Buffer" . lua-send-buffer))
(define-key lua-mode-menu [search-documentation]
  '("Search Documentation" . lua-search-documentation))


(provide 'lua-mode)

;;; lua-mode.el ends here


;;; xah-find.el --- find replace in pure emacs lisp. Purpose similar to grep/sed. -*- coding: utf-8; lexical-binding: t; -*-

;; Copyright © 2012-2018 by Xah Lee

;; Author: Xah Lee ( http://xahlee.info/ )
;; Version: 4.2.20181201024903
;; Created: 02 April 2012
;; Package-Requires: ((emacs "24.1"))
;; Keywords: convenience, extensions, files, tools, unix
;; License: GPL v3
;; Homepage: http://ergoemacs.org/emacs/elisp-xah-find-text.html

;; This file is not part of GNU Emacs.

;;; Commentary:

;; Provides emacs commands for find/replace text of files in a directory, written entirely in emacs lisp.

;; This package provides these commands:

;; xah-find-text
;; xah-find-text-regex
;; xah-find-count
;; xah-find-replace-text
;; xah-find-replace-text-regex

;;  Pure emacs lisp. No dependencies on unix/linux grep/sed/find. Especially useful on Windows.

;;  Output is highlighted and clickable for jumping to occurrence.

;;  Using emacs regex, not bash/perl etc regex.

;; These commands treats find/replace string as sequence of chars, not as lines as in grep/sed, so it's easier to find or replace a text containing lots newlines, especially programming language source code.

;;  Reliably Find/Replace string that contains newline chars.

;;  Reliably Find/Replace string that contains lots Unicode chars. See http://xahlee.info/comp/unix_uniq_unicode_bug.html and http://ergoemacs.org/emacs/emacs_grep_problem.html

;;  Reliably Find/Replace string that contains lots escape slashes or backslashes. For example, regex in source code, Microsoft Windows' path.

;; The result output is also not based on lines. Instead, visual separators are used for easy reading.

;; For each occurrence or replacement, n chars will be printed before and after. The number of chars to show is defined by `xah-find-context-char-count-before' and `xah-find-context-char-count-after'

;; Each “block of text” in output is one occurrence.
;; For example, if a line in a file has 2 occurrences, then the same line will be reported twice, as 2 “blocks”.
;; so, the number of blocks corresponds exactly to the number of occurrences.

;; Keys
;; -----------------------
;; TAB             xah-find-next-match
;; <backtab>       xah-find-previous-match

;; RET             xah-find--jump-to-place
;; <mouse-1>       xah-find--mouse-jump-to-place

;; <left>          xah-find-previous-match
;; <right>         xah-find-next-match

;; <down>          xah-find-next-file
;; <up>            xah-find-previous-file

;; M-n             xah-find-next-file
;; M-p             xah-find-previous-file

;; IGNORE DIRECTORIES

;; By default, .git dir is ignored. You can add to it by adding the following in your init:

;; (setq
;;  xah-find-dir-ignore-regex-list
;;  [
;;   "\\.git/"
;;    ; more regex here. regex is matched against file full path
;;   ])

;; to customize the color for matched text, call `customize-group' and then give xah-find.

;; USE CASE

;; To give a idea what file size, number of files, are practical, here's my typical use pattern:
;;  5 thousand HTML files match file name regex.
;;  Each HTML file size are usually less than 200k bytes.
;;  search string length have been up to 13 lines of text.

;; Homepage: http://ergoemacs.org/emacs/elisp-xah-find-text.html

;; Like it?
;; Buy Xah Emacs Tutorial
;; http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html
;; Thank you.

;;; INSTALL

;; To install manually, place this file in the directory 〔~/.emacs.d/lisp/〕

;; Then, place the following code in your emacs init file

;; (add-to-list 'load-path "~/.emacs.d/lisp/")
;; (autoload 'xah-find-text "xah-find" "find replace" t)
;; (autoload 'xah-find-text-regex "xah-find" "find replace" t)
;; (autoload 'xah-find-replace-text "xah-find" "find replace" t)
;; (autoload 'xah-find-replace-text-regex "xah-find" "find replace" t)
;; (autoload 'xah-find-count "xah-find" "find replace" t)

;;; HISTORY

;; version 2.1.0, 2015-05-30 Complete rewrite.
;; version 1.0, 2012-04-02 First version.

;;; CONTRIBUTOR
;; 2015-12-09 Peter Buckley (dx-pbuckley). defcustom for result highlight color.


;;; Code:

(require 'ido)       ; in emacs
(ido-common-initialization) ; 2015-07-26 else, when ido-read-directory-name is called, Return key insert line return instead of submit. For some reason i dunno.

(defcustom
  xah-find-context-char-count-before
  100
  "Number of characters to print before search string."
  :group 'xah-find
  )

(defcustom xah-find-context-char-count-after
  50
  "Number of characters to print after search string."
  :group 'xah-find
  )

(defcustom xah-find-dir-ignore-regex-list
  [
   "\\.git/"
   ]
  "A list or vector of regex patterns, if match, that directory will be ignored. Case is dependent on current value of `case-fold-search'"
  :group 'xah-find
  )

(defface xah-find-file-path-highlight
  '((t :foreground "black"
       :background "pink"
       ))
  "Face of file path where a text match is found."
  :group 'xah-find )

(defface xah-find-match-highlight
  '((t :foreground "black"
       :background "yellow"
       ))
  "Face for matched text."
  :group 'xah-find )

(defface xah-find-replace-highlight
  '((t :foreground "black"
       :background "green"
       ))
  "Face for replaced text."
  :group 'xah-find )

(defcustom xah-find-file-separator
  "ff━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
  "A string as visual separator."
  :group 'xah-find )

(defcustom
  xah-find-occur-separator
  "oo────────────────────────────────────────────────────────────\n\n"
  "A string as visual separator."
  :group 'xah-find )

(defcustom xah-find-occur-prefix
  "〖"
  "A left-bracket string that marks matched text and navigate previous/next. This string should basically never occure in your files. If it does, jumping to the location may not work."
  :group 'xah-find
  )

(defcustom xah-find-occur-postfix
  "〗"
  "A right-bracket string that marks matched text and navigate previous/next. See also `xah-find-occur-prefix'."
  :group 'xah-find
  )

(defcustom xah-find-replace-prefix
  "『"
  "A left-bracket string that marks matched text and navigate previous/next. See also `xah-find-occur-prefix'."
  :group 'xah-find
  )

(defcustom xah-find-replace-postfix
  "』"
  "A right-bracket string that marks matched text and navigate previous/next. See also `xah-find-occur-prefix'."
  :group 'xah-find
  )

;; more brackets at
;; http://xahlee.info/comp/unicode_matching_brackets.html

(defcustom xah-find-filepath-prefix
  "〘"
  "A left-bracket string used to mark file path and navigate previous/next. See also `xah-find-occur-prefix'."
  :group 'xah-find
  )

(defcustom xah-find-filepath-postfix
  "〙"
  "A right-bracket string used to mark file path and navigate previous/next. See also `xah-find-occur-prefix'."
  :group 'xah-find
  )

(defcustom xah-find-pos-prefix
  "❪"
  "A string of left bracket that marks line column position of occurrence. See also `xah-find-occur-prefix'."
  :group 'xah-find
  )

(defcustom xah-find-pos-postfix
  "❫"
  "A string of right bracket that marks line column position of occurrence. See also `xah-find-occur-prefix'."
  :group 'xah-find
  )



(defvar xah-find-file-path-regex-history '() "File path regex history list, used by `xah-find-text' and others.")

(defun xah-find--filter-list (@predicate @sequence)
  "Return a new list such that @PREDICATE is true on all members of @SEQUENCE.
 nil elements are also removed.
 @SEQUENCE is destroyed.
URL `http://ergoemacs.org/emacs/elisp_filter_list.html'
Version 2018-09-22"
  (delq
   nil
   (mapcar
    (lambda (x)
      (if (funcall @predicate x)
          x
        nil ))
    @sequence)))

(defun xah-find--ignore-dir-p (@path )
  "Return true if one of `xah-find-dir-ignore-regex-list' matches @PATH. Else, nil.
2016-11-16"
  (catch 'exit25001
    (mapc
     (lambda ($regex)
       (when (string-match $regex @path) (throw 'exit25001 $regex)))
     xah-find-dir-ignore-regex-list)
    nil
    ))


(defvar xah-find-output-mode-map nil "Keybinding for `xah-find.el output'")
(progn
  (setq xah-find-output-mode-map (make-sparse-keymap))

  (define-key xah-find-output-mode-map (kbd "<left>") 'xah-find-previous-match)
  (define-key xah-find-output-mode-map (kbd "<right>") 'xah-find-next-match)
  (define-key xah-find-output-mode-map (kbd "<down>") 'xah-find-next-file)
  (define-key xah-find-output-mode-map (kbd "<up>") 'xah-find-previous-file)

  (define-key xah-find-output-mode-map (kbd "TAB") 'xah-find-next-match)
  (define-key xah-find-output-mode-map (kbd "<backtab>") 'xah-find-previous-match)
  (define-key xah-find-output-mode-map (kbd "<mouse-1>") 'xah-find--mouse-jump-to-place)
  (define-key xah-find-output-mode-map (kbd "M-n") 'xah-find-next-file)
  (define-key xah-find-output-mode-map (kbd "M-p") 'xah-find-previous-file)
  (define-key xah-find-output-mode-map (kbd "RET") 'xah-find--jump-to-place)
  )

(defvar xah-find-output-syntax-table nil "Syntax table for `xah-find-output-mode'.")

(setq xah-find-output-syntax-table
      (let ( (synTable (make-syntax-table)))
        (modify-syntax-entry ?\" "." synTable)
        ;; (modify-syntax-entry ?〖 "(〗" synTable)
        ;; (modify-syntax-entry ?〗 "(〖" synTable)
        synTable))

(setq xah-find-font-lock-keywords
      (let (
            (xMatch (format "%s\\([^%s]+\\)%s" xah-find-occur-prefix xah-find-occur-postfix xah-find-occur-postfix))

            (xRep (format "%s\\([^%s]+\\)%s" xah-find-replace-prefix xah-find-replace-postfix xah-find-replace-postfix))
            (xfPath (format "%s\\([^%s]+\\)%s" xah-find-filepath-prefix xah-find-filepath-postfix xah-find-filepath-postfix)))

        `(
          (,xMatch  . (1 'xah-find-match-highlight))
          (,xRep . (1 'xah-find-replace-highlight))
          (,xfPath . (1 'xah-find-file-path-highlight)))))

(define-derived-mode xah-find-output-mode fundamental-mode "∑xah-find"
  "Major mode for reading output for xah-find commands.
home page:
URL `http://ergoemacs.org/emacs/elisp-xah-find-text.html'

\\{xah-find-output-mode-map}"

  (setq font-lock-defaults '((xah-find-font-lock-keywords)))

  (set-syntax-table xah-find-output-syntax-table)

  (progn
    (when (null buffer-display-table)
      (setq buffer-display-table (make-display-table)))
    (aset buffer-display-table ?\^L
          (vconcat (make-list 70 (make-glyph-code ?─ 'font-lock-comment-face)))))

  :group 'xah-find
  )

(defun xah-find-next-match ()
  "Put cursor to next occurrence."
  (interactive)
  (search-forward xah-find-occur-prefix nil "NOERROR" ))

(defun xah-find-previous-match ()
  "Put cursor to previous occurrence."
  (interactive)
  (search-backward xah-find-occur-postfix nil "NOERROR" )
  (left-char) ; todo. this is a hack. move point to inside of text with highlight property, so it's clickable. Look into modify xah-find--jump-to-place instead
  )

(defun xah-find-next-file ()
  "Put cursor to next file."
  (interactive)
  (search-forward xah-find-filepath-prefix nil "NOERROR" ))

(defun xah-find-previous-file ()
  "Put cursor to previous file."
  (interactive)
  (search-backward xah-find-filepath-postfix nil "NOERROR" )
  (left-char) ; todo. this is a hack. move point to inside of text with highlight property, so it's clickable. Look into modify xah-find--jump-to-place instead
  )

(defun xah-find--mouse-jump-to-place (@event)
  "Open file and put cursor at location of the occurrence.
Version 2016-12-18"
  (interactive "e")
  (let* (
         ($pos (posn-point (event-end @event)))
         ($fpath (get-text-property $pos 'xah-find-fpath))
         ($pos-jump-to (get-text-property $pos 'xah-find-pos)))
    (when (not (null $fpath))
      (progn
        (find-file-other-window $fpath)
        (when $pos-jump-to (goto-char $pos-jump-to))))))

;; (defun xah-find--jump-to-place ()
;;   "Open file and put cursor at location of the occurrence.
;; Version 2017-04-07"
;;   (interactive)
;;   (let (($fpath (get-text-property (point) 'xah-find-fpath))
;;         ($pos-jump-to (get-text-property (point) 'xah-find-pos)))
;;     (if $fpath
;;         (if (file-exists-p $fpath)
;;             (progn
;;               (find-file-other-window $fpath)
;;               (when $pos-jump-to (goto-char $pos-jump-to)))
;;           (error "File at 「%s」 does not exist." $fpath))
;;       (insert "\n"))))

(defun xah-find--jump-to-place ()
  "Open file and put cursor at location of the occurrence.
Version 2018-10-21"
  (interactive)
  (let (($fpath (get-text-property (point) 'xah-find-fpath))
        ($pos-jump-to (get-text-property (point) 'xah-find-pos))
        (p0 (point))
        p1 p2
        )
    (if $fpath
        (if (file-exists-p $fpath)
            (progn
              (find-file-other-window $fpath)
              (when $pos-jump-to (goto-char $pos-jump-to)))
          (error "File at 「%s」 does not exist." $fpath))
      (progn
        (save-excursion
          (goto-char p0)
          (search-forward xah-find-file-separator)
          (search-backward xah-find-filepath-prefix )
          (setq p1 (1+ (point)))
          (search-forward xah-find-filepath-postfix)
          (setq p2 (1- (point)))
          (setq $fpath (buffer-substring-no-properties p1 p2))

          (goto-char p0)
          (search-backward xah-find-pos-prefix )
          (setq p1 (1+ (point)))
          (search-forward xah-find-pos-postfix )
          (setq p2 (1- (point)))
          (setq $pos-jump-to (string-to-number (buffer-substring-no-properties p1 p2))))
        (if (file-exists-p $fpath)
            (progn
              (find-file-other-window $fpath)
              (when $pos-jump-to (goto-char $pos-jump-to)))
          (error "File at 「%s」 does not exist." $fpath))))))


(defun xah-find--backup-suffix (@s)
  "Return a string of the form 「~@s~date time stamp~」"
  (concat "~" @s (format-time-string "%Y%m%dT%H%M%S") "~"))

(defun xah-find--current-date-time-string ()
  "Return current date-time string in this format 「2012-04-05T21:08:24-07:00」"
  (concat
   (format-time-string "%Y-%m-%dT%T")
   (funcall (lambda (x) (format "%s:%s" (substring x 0 3) (substring x 3 5))) (format-time-string "%z"))))

(defun xah-find--print-header (@bufferObj @cmd @input-dir @path-regex @search-str &optional @replace-str @write-file-p @backup-p)
  "Print things"
  (princ
   (concat
    "-*- coding: utf-8; mode: xah-find-output -*-" "\n"
    "Datetime: " (xah-find--current-date-time-string) "\n"
    "Result of: " @cmd "\n"
    (format "Directory: %s\n" @input-dir )
    (format "Path regex: %s\n" @path-regex )
    (format "Write to file: %s\n" @write-file-p )
    (format "Backup: %s\n" @backup-p )
    (format "Search string: %s\n" @search-str )
    (when @replace-str (format "Replace string ❬%s❭\n" @replace-str))
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
    )
   @bufferObj))

(defun xah-find--occur-output (@p1 @p2 @fpath @buff &optional @no-context-string-p @alt-color)
  "Print result to a output buffer, with text properties (e.g. highlight and link).
@p1 @p2 are region boundary. Region of current buffer are grabbed. The region typically is the searched text.
@fpath is file path to be used as property value for clickable link.
@buff is the buffer to insert @p1 @p2 region.
@no-context-string-p if true, don't add text before and after the region of interest. Else, `xah-find-context-char-count-before' number of chars are inserted before, and similar for `xah-find-context-char-count-after'.
@alt-color if true, use a different highlight color face `xah-find-replace-highlight'. Else, use `xah-find-match-highlight'.
 2017-04-07"
  (let* (
         ($begin (max 1 (- @p1 xah-find-context-char-count-before )))
         ($end (min (point-max) (+ @p2 xah-find-context-char-count-after )))
         ($textBefore (if @no-context-string-p "" (buffer-substring-no-properties $begin @p1 )))
         $textMiddle
         ($textAfter (if @no-context-string-p "" (buffer-substring-no-properties @p2 $end)))
         ($face (if @alt-color 'xah-find-replace-highlight 'xah-find-match-highlight))
         $bracketL
         $bracketR
         $positionText
         )
    (put-text-property @p1 @p2 'face $face)
    (put-text-property @p1 @p2 'xah-find-fpath @fpath)
    (put-text-property @p1 @p2 'xah-find-pos @p1)
    (add-text-properties @p1 @p2 '(mouse-face highlight))

    (setq $textMiddle (buffer-substring @p1 @p2 ))

    (if @alt-color
        (setq $bracketL xah-find-replace-prefix $bracketR xah-find-replace-postfix )
      (setq $bracketL xah-find-occur-prefix $bracketR xah-find-occur-postfix ))

    (with-current-buffer @buff
      (insert
       (format "%s%s%s\n" xah-find-pos-prefix @p1 xah-find-pos-postfix)
       $textBefore
       $bracketL
       $textMiddle
       $bracketR
       $textAfter
       "\n"
       xah-find-occur-separator ))))

;; (defun xah-find--print-replace-block (@p1 @p2 @buff)
;;   "print "
;;   (princ (concat "❬" (buffer-substring-no-properties @p1 @p2 ) "❭" "\n" xah-find-occur-separator) @buff))

(defun xah-find--print-file-count (@filepath4287 @count8086 @buffObj32)
  "Print file path and count"
  (princ (format "%d %s%s%s\n%s"
                 @count8086
                 xah-find-filepath-prefix
                 @filepath4287
                 xah-find-filepath-postfix
                 xah-find-file-separator)
         @buffObj32))

;; (defun xah-find--highlight-output (@buffer &optional @search-str @replace-str)
;;   "switch to @buffer and highlight stuff"
;;   (let (($search (concat xah-find-occur-prefix @search-str xah-find-occur-postfix))
;;         ($rep (concat "❬" @replace-str "❭")))
;;     (switch-to-buffer @buffer)
;;     (fundamental-mode)
;;     (progn
;;       (goto-char 1)
;;       (while (search-forward-regexp "❨\\([^❩]+?\\)❩" nil "NOERROR")
;;         (put-text-property
;;          (match-beginning 0)
;;          (match-end 0)
;;          'face (list :background "yellow"))))
;;     (progn
;;       (goto-char 1)
;;       (while (search-forward-regexp "❬\\([^❭]+?\\)❭" nil "NOERROR")
;;         (put-text-property
;;          (match-beginning 0)
;;          (match-end 0)
;;          'face (list :background "green"))))
;;     (progn
;;       (goto-char 1)
;;       (while (search-forward xah-find-filepath-prefix nil "NOERROR")
;;         (put-text-property
;;          (line-beginning-position)
;;          (line-end-position)
;;          'face (list :background "pink"))))
;;     (goto-char 1)
;;     (search-forward-regexp "━+" nil "NOERROR")
;;     (use-local-map xah-find-output-mode-map)))

(defun xah-find--switch-to-output (@buffer)
  "switch to @buffer and highlight stuff"
  (let ($p3 $p4)
    (switch-to-buffer @buffer)
    (progn
      (goto-char 1)
      (while (search-forward xah-find-filepath-prefix nil "NOERROR")
        (setq $p3 (point))
        (search-forward xah-find-filepath-postfix nil "NOERROR")
        (setq $p4 (- (point) (length xah-find-filepath-postfix)))
        (put-text-property $p3 $p4 'xah-find-fpath (buffer-substring-no-properties $p3 $p4))
        (add-text-properties $p3 $p4 '(mouse-face highlight))
        (put-text-property (line-beginning-position) (line-end-position) 'face 'xah-find-file-path-highlight)))

    (goto-char 1)
    (search-forward "━" nil "NOERROR") ; todo, need fix
    (search-forward xah-find-occur-prefix nil "NOERROR")
    (xah-find-output-mode)
    ))



;;;###autoload
(defun xah-find-count (@search-str @count-expr @count-number @input-dir @path-regex)
  "Report how many occurrences of a string, of a given dir.
Similar to `rgrep', but written in pure elisp.
Result is shown in buffer *xah-find output*.
Case sensitivity is determined by `case-fold-search'. Call `toggle-case-fold-search' to change.
\\{xah-find-output-mode-map}"
  (interactive
   (let ( $operator)
     (list
      (read-string (format "Search string (default %s): " (current-word)) nil 'query-replace-history (current-word))
      (setq $operator (ido-completing-read "Report on: " '("greater than" "greater or equal to" "equal" "not equal" "less than" "less or equal to" )))
      (read-string (format "Count %s: "  $operator) "0")
      (ido-read-directory-name "Directory: " default-directory default-directory "MUSTMATCH")
      (read-from-minibuffer "File path regex: " (xah-find--get-default-file-extension-regex "el") nil nil 'dired-regexp-history))))
  (let* (($outBufName "*xah-find output*")
         $outBuffer
         ($countOperator
          (cond
           ((string-equal "less than" @count-expr ) '<)
           ((string-equal "less or equal to" @count-expr ) '<=)
           ((string-equal "greater than" @count-expr ) '>)
           ((string-equal "greater or equal to" @count-expr ) '>=)
           ((string-equal "equal" @count-expr ) '=)
           ((string-equal "not equal" @count-expr ) '/=)
           (t (error "count expression 「%s」 is wrong!" @count-expr ))))
         ($countNumber (string-to-number @count-number)))
    (when (get-buffer $outBufName) (kill-buffer $outBufName))
    (setq $outBuffer (generate-new-buffer $outBufName))
    (xah-find--print-header $outBuffer "xah-find-count" @input-dir @path-regex @search-str )
    (mapc
     (lambda ($f)
       (let (($count 0))
         (with-temp-buffer
           (insert-file-contents $f)
           (goto-char 1)
           (while (search-forward @search-str nil "NOERROR") (setq $count (1+ $count)))
           (when (funcall $countOperator $count $countNumber)
             (xah-find--print-file-count $f $count $outBuffer)))))
     (xah-find--filter-list (lambda (x) (not (xah-find--ignore-dir-p x)))
                            (directory-files-recursively @input-dir @path-regex)))
    (princ "Done." $outBuffer)
    (xah-find--switch-to-output $outBuffer)))

(defun xah-find--get-default-file-extension-regex (&optional @default-ext)
  "Returns a string, that is a regex to match a file extension.
The result is based on current buffer's file extension.
If current file doesn't have extension or current buffer isn't a file, then extension @default-ext is used.
@default-ext should be a string, without dot, such as 「\"html\"」.
If @default-ext is nil, 「\"html\"」 is used.
Example return value: 「ββ.htmlββ'」, where β is a backslash.
"
  (let (
        ($buff-is-file-p (buffer-file-name))
        $fname-ext
        $default-ext
        )
    (setq $default-ext (if (null @default-ext)
                           (progn "html")
                         (progn @default-ext)))
    (if $buff-is-file-p
        (progn
          (setq $fname-ext (file-name-extension (buffer-file-name)))
          (if (or (null $fname-ext) (equal $fname-ext ""))
              (progn (concat "\\." $default-ext "$"))
            (progn (concat "\\." $fname-ext "$"))))
      (progn (concat "\\." $default-ext "$")))))

;;;###autoload
(defun xah-find-text (@search-str1 @input-dir @path-regex @fixed-case-search-p @printContext-p)
  "Report files that contain string.
By default, not case sensitive, and print surrounding text.
If `universal-argument' is called first, prompt to ask.
Result is shown in buffer *xah-find output*.
\\{xah-find-output-mode-map}"
  (interactive
   (let (($default-input (if (use-region-p) (buffer-substring-no-properties (region-beginning) (region-end)) (current-word))))
     (list
      (read-string (format "Search string (default %s): " $default-input) nil 'query-replace-history $default-input)
      (ido-read-directory-name "Directory: " default-directory default-directory "MUSTMATCH")
      (read-from-minibuffer "File path regex: " (xah-find--get-default-file-extension-regex "html") nil nil 'dired-regexp-history)
      (if current-prefix-arg (y-or-n-p "Fixed case in search?") nil )
      (if current-prefix-arg (y-or-n-p "Print surrounding Text?") t ))))
  (let* ((case-fold-search (not @fixed-case-search-p))
         ($count 0)
         ($outBufName "*xah-find output*")
         $outBuffer
         )
    (setq @input-dir (file-name-as-directory @input-dir)) ; normalize dir path
    (when (get-buffer $outBufName) (kill-buffer $outBufName))
    (setq $outBuffer (generate-new-buffer $outBufName))
    (xah-find--print-header $outBuffer "xah-find-text" @input-dir @path-regex @search-str1  )
    (mapc
     (lambda ($path)
       (setq $count 0)
       (with-temp-buffer
         (insert-file-contents $path)
         (while (search-forward @search-str1 nil "NOERROR")
           (setq $count (1+ $count))
           (when @printContext-p (xah-find--occur-output (match-beginning 0) (match-end 0) $path $outBuffer)))
         (when (> $count 0) (xah-find--print-file-count $path $count $outBuffer))))
     (xah-find--filter-list (lambda (x) (not (xah-find--ignore-dir-p x)))
                            (directory-files-recursively @input-dir @path-regex)))
    (princ "Done." $outBuffer)
    (xah-find--switch-to-output $outBuffer)))

;;;###autoload
(defun xah-find-replace-text (@search-str @replace-str @input-dir @path-regex @write-to-file-p @fixed-case-search-p @fixed-case-replace-p &optional @backup-p)
  "Find/Replace string in all files of a directory.
Search string can span multiple lines.
No regex.

Backup, if requested, backup filenames has suffix with timestamp, like this: ~xf20150531T233826~

Result is shown in buffer *xah-find output*.
\\{xah-find-output-mode-map}"
  (interactive
   (let ( x-search-str x-replace-str x-input-dir x-path-regex x-write-to-file-p x-fixed-case-search-p x-fixed-case-replace-p x-backup-p )
     (setq x-search-str (read-string (format "Search string (default %s): " (current-word)) nil 'query-replace-history (current-word)))
     (setq x-replace-str (read-string (format "Replace string: ") nil 'query-replace-history))
     (setq x-input-dir (ido-read-directory-name "Directory: " default-directory default-directory "MUSTMATCH"))
     (setq x-path-regex (read-from-minibuffer "File path regex: " (xah-find--get-default-file-extension-regex "el") nil nil 'dired-regexp-history))
     (setq x-write-to-file-p (y-or-n-p "Write changes to file?"))
     (setq x-fixed-case-search-p (y-or-n-p "Fixed case in search?"))
     (setq x-fixed-case-replace-p (y-or-n-p "Fixed case in replacement?"))
     (if x-write-to-file-p
         (setq x-backup-p (y-or-n-p "Make backup?"))
       (setq x-backup-p nil))
     (list x-search-str x-replace-str x-input-dir x-path-regex x-write-to-file-p x-fixed-case-search-p x-fixed-case-replace-p x-backup-p )))
  (let (($outBufName "*xah-find output*")
        $outBuffer
        ($backupSuffix (xah-find--backup-suffix "xf")))
    (when (get-buffer $outBufName) (kill-buffer $outBufName))
    (setq $outBuffer (generate-new-buffer $outBufName))
    (xah-find--print-header $outBuffer "xah-find-replace-text" @input-dir @path-regex @search-str @replace-str @write-to-file-p @backup-p)
    (mapc
     (lambda ($f)
       (let ((case-fold-search (not @fixed-case-search-p))
             ($count 0))
         (with-temp-buffer
           (insert-file-contents $f)
           (while (search-forward @search-str nil t)
             (setq $count (1+ $count))
             (replace-match @replace-str @fixed-case-replace-p "literalreplace")
             (xah-find--occur-output (match-beginning 0) (point) $f $outBuffer))
           (when (> $count 0)
             (when @write-to-file-p
               (when @backup-p (copy-file $f (concat $f $backupSuffix) t))
               (write-region 1 (point-max) $f nil 3))
             (xah-find--print-file-count $f $count $outBuffer )))))
     (xah-find--filter-list (lambda (x) (not (xah-find--ignore-dir-p x)))
                            (directory-files-recursively @input-dir @path-regex)))
    (princ "Done." $outBuffer)
    (xah-find--switch-to-output $outBuffer)))

;;;###autoload
(defun xah-find-text-regex (@search-regex @input-dir @path-regex @fixed-case-search-p @print-context-level )
  "Report files that contain a string pattern, similar to `rgrep'.
Result is shown in buffer *xah-find output*.
\\{xah-find-output-mode-map}
Version 2016-12-21"
  (interactive
   (list
    (read-string (format "Search regex (default %s): " (current-word)) nil 'query-replace-history (current-word))
    (ido-read-directory-name "Directory: " default-directory default-directory "MUSTMATCH")
    (read-from-minibuffer "File path regex: " (xah-find--get-default-file-extension-regex "el") nil nil 'dired-regexp-history)
    (y-or-n-p "Fixed case search?")
    (ido-completing-read "Print context level: " '("with context string" "just matched pattern" "none" ))))
  (let (($count 0)
        ($outBufName "*xah-find output*")
        $outBuffer
        )
    (setq @input-dir (file-name-as-directory @input-dir)) ; add ending slash
    (when (get-buffer $outBufName) (kill-buffer $outBufName))
    (setq $outBuffer (generate-new-buffer $outBufName))
    (xah-find--print-header $outBuffer "xah-find-text-regex" @input-dir @path-regex @search-regex  )
    (mapc
     (lambda ($fp)
       (setq $count 0)
       (with-temp-buffer
         (insert-file-contents $fp)
         (setq case-fold-search (not @fixed-case-search-p))
         (while (search-forward-regexp @search-regex nil t)
           (setq $count (1+ $count))
           (cond
            ((equal @print-context-level "none") nil)
            ((equal @print-context-level "just matched pattern")
             (xah-find--occur-output (match-beginning 0) (match-end 0) $fp $outBuffer t))
            ((equal @print-context-level "with context string")
             (xah-find--occur-output (match-beginning 0) (match-end 0) $fp $outBuffer))))
         (when (> $count 0) (xah-find--print-file-count $fp $count $outBuffer))))
     (xah-find--filter-list (lambda (x) (not (xah-find--ignore-dir-p x)))
                            (directory-files-recursively @input-dir @path-regex)))
    (princ "Done." $outBuffer)
    (xah-find--switch-to-output $outBuffer)))

;;;###autoload
(defun xah-find-replace-text-regex (@regex @replace-str @input-dir @path-regex @write-to-file-p @fixed-case-search-p @fixed-case-replace-p @show-contex-p @backup-p)
  "Find/Replace by regex in all files of a directory.

Backup, if requested, backup filenames has suffix with timestamp, like this: ~xf20150531T233826~

When called in lisp code:
@REGEX is a regex pattern.
@REPLACE-STR is replacement string.
@INPUT-DIR is input directory to search (includes all nested subdirectories).
@PATH-REGEX is a regex to filter file paths.
@WRITE-TO-FILE-P, when true, write to file, else, print a report of changes only.
@FIXED-CASE-SEARCH-P sets `case-fold-search' for this operation.
@FIXED-CASE-REPLACE-P if true, then the letter-case in replacement is literal. (this is relevant only if @FIXED-CASE-SEARCH-P is true.)
Result is shown in buffer *xah-find output*.
\\{xah-find-output-mode-map}

Version 2018-08-20"
  (interactive
   (list
    (read-regexp "Find regex: " )
    (read-string (format "Replace string: ") nil 'query-replace-history)
    (ido-read-directory-name "Directory: " default-directory default-directory "MUSTMATCH")
    (read-from-minibuffer "File path regex: " (xah-find--get-default-file-extension-regex "el") nil nil 'dired-regexp-history)
    (y-or-n-p "Write changes to file?")
    (y-or-n-p "Fixed case in search?")
    (y-or-n-p "Fixed case in replacement?")
    (y-or-n-p "Show context before after in output?")
    (y-or-n-p "Make backup?")))
  (let (($outBufName "*xah-find output*")
        $outBuffer
        ($backupSuffix (xah-find--backup-suffix "xfr")))
    (when (get-buffer $outBufName) (kill-buffer $outBufName))
    (setq $outBuffer (generate-new-buffer $outBufName))
    (xah-find--print-header $outBuffer "xah-find-replace-text-regex" @input-dir @path-regex @regex @replace-str @write-to-file-p @backup-p )
    (mapc
     (lambda ($fp)
       (let (($count 0))
         (with-temp-buffer
           (insert-file-contents $fp)
           (setq case-fold-search (not @fixed-case-search-p))
           (while (re-search-forward @regex nil t)
             (setq $count (1+ $count))
             ;; (xah-find--print-occur-block (match-beginning 0) (match-end 0) $outBuffer)
             (xah-find--occur-output (match-beginning 0) (match-end 0) $fp $outBuffer t)
             (replace-match @replace-str @fixed-case-replace-p)
             (xah-find--occur-output (match-beginning 0) (point) $fp $outBuffer (not @show-contex-p) t))
           (when (> $count 0)
             (xah-find--print-file-count $fp $count $outBuffer)
             (when @write-to-file-p
               (when @backup-p
                 (copy-file $fp (concat $fp $backupSuffix) t))
               (write-region 1 (point-max) $fp nil 3))))))
     (xah-find--filter-list (lambda (x) (not (xah-find--ignore-dir-p x)))
                            (directory-files-recursively @input-dir @path-regex)))
    (princ "Done." $outBuffer)
    (xah-find--switch-to-output $outBuffer)))

(provide 'xah-find)

;;; xah-find.el ends here

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(completion-styles (quote (basic)))
 '(package-selected-packages
   (quote
    (helm csharp-mode yasnippet company-lsp lsp-mode dumb-jump expand-region use-package))))
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )


;;; xahk-mode.el --- Major mode for editing AutoHotkey scripts. -*- coding: utf-8; lexical-binding: t; -*-

;; Copyright © 2008-2016 by Xah Lee

;; Author: Xah Lee ( http://xahlee.info/ )
;; Version: 1.4.1
;; Created: 09 Jan 2010
;; Package-Requires: ((emacs "24.1"))
;; Keywords: languages
;; License: GPL v3
;; Homepage: http://xahlee.info/mswin/emacs_autohotkey_mode.html

;;; Commentary:

;; A major mode for editing AutoHotkey (AHK) script.

;; for download location and documentation, see:
;; http://xahlee.info/mswin/emacs_autohotkey_mode.html

;; Like it?
;; Buy Xah Emacs Tutorial
;; http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html

;;; INSTALL:

;; Open the file, then type “Alt+x eval-buffer”. You are done. Open any AHK script, then type “Alt+x xahk-mode”, you'll see the source code syntax colored.

;; To make emacs load it on startup:

;; 1, Put the file 〔xahk-mode.el〕 in the dir 〔~/.emacs.d/lisp/〕 (create the dir if it doesn't exist)
;; 2, Put the following lines in your emacs init file (usually at 〔~/.emacs〕).

;; (add-to-list 'load-path "~/.emacs.d/lisp/")
;; (autoload 'xahk-mode "xahk-mode" "Load xahk-mode for editing AutoHotkey scripts." t)

;; Restart emacs.

;;  file ending in .ahk will be opened in xahk-mode.
;;  You can call xahk-mode anytime
;;  ahk-mode is setup as a alias to xahk-mode

;;; HISTORY

;; 2015-05-05 only major change will be logged here.

;; version 1.3.2, 2016-12-18 turned on lexical-binding
;; version 1.3.0, 2015-05-04 major refactor. Submit to MELPA.
;; version 1.2.2, 2012-05-21 modified syntax table so “_” is part of word.
;; version 1.2.1, 2011-10-15 Minor changes. No visible behavior change.
;; version 1.2, 2010-02-17 fixed a defect where if source contains “"C:\"”, everything after is badly syntax colored. Thanks to “xinlu.h” and “iain.tuddenham”. Detail at http://code.google.com/p/ergoemacs/issues/detail?id=66
;; version 1.1, 2010-01-14 Added indentation feature. (press Tab to indent.)
;; version 1.0, 2010-01-09 First version.

;;; Code:

(require 'thingatpt )

(defconst xahk-mode-version "")
(setq xahk-mode-version "1.3.2")

(defgroup xahk-mode nil
  "Major mode for editing AutoHotkey script."
  :group 'languages)

(defvar xahk-mode-command-name-face 'xahk-mode-command-name-face "Face name to use for AHK command names.")

(defface xahk-mode-command-name-face
  '((((class color) (min-colors 88) (background light)) (:foreground "Blue1"))
    (((class color) (min-colors 88) (background dark)) (:foreground "LightSkyBlue"))
    (((class color) (min-colors 16) (background light)) (:foreground "Blue"))
    (((class color) (min-colors 16) (background dark)) (:foreground "LightSkyBlue"))
    (((class color) (min-colors 8)) (:foreground "blue" :weight bold))
    (t (:inverse-video t :weight bold)))
  "Face used to highlight AHK command names."
  :group 'languages)

(defvar xahk-mode-hook nil "Standard hook for xahk-mode.")

(defvar xahk-mode-version nil "xahk-mode version string.")

(defvar xahk-mode-map nil "Keymap for xahk-mode")
(progn
  (setq xahk-mode-map (make-sparse-keymap))
  (define-key xahk-mode-map (kbd "C-c C-r") 'xahk-lookup-ahk-ref)
  (define-key xahk-mode-map (kbd "M-TAB") 'xahk-complete-symbol)

  (define-key xahk-mode-map [menu-bar] (make-sparse-keymap))

  (let ((menuMap (make-sparse-keymap "AHK")))
    (define-key xahk-mode-map [menu-bar xahk] (cons "AHK" menuMap))

    (define-key menuMap [goto-home-page] '("Goto xahk-mode website" . (lambda () (interactive) (browse-url "http://xahlee.info/mswin/emacs_autohotkey_mode.html"))))
    (define-key menuMap [about] '("About xahk-mode" . xahk-about))
    (define-key menuMap [separator] '("--"))
    (define-key menuMap [lookup-onlne-doc] '("Lookup ref on current word" . xahk-lookup-ahk-ref))
    (define-key menuMap [keyword-completion] '("Keyword Completion" . xahk-complete-symbol))))

;;; syntax table
(defvar xahk-mode-syntax-table nil "Syntax table for `xahk-mode'.")
(setq xahk-mode-syntax-table
      (let ((synTable (make-syntax-table)))
	(modify-syntax-entry ?\; "< b" synTable)
	(modify-syntax-entry ?\n "> b" synTable)
	(modify-syntax-entry ?! "." synTable)
	(modify-syntax-entry ?@ "." synTable)
	(modify-syntax-entry ?# "'" synTable)
	(modify-syntax-entry ?$ "." synTable)
	(modify-syntax-entry ?% "." synTable)
	(modify-syntax-entry ?^ "." synTable)
	(modify-syntax-entry ?& "." synTable)
	(modify-syntax-entry ?* "." synTable)
	(modify-syntax-entry ?` "\\" synTable) ; ` is escape
	(modify-syntax-entry ?~ "." synTable)
	(modify-syntax-entry ?: "." synTable)
	(modify-syntax-entry ?' "." synTable)
	(modify-syntax-entry ?| "." synTable)
	(modify-syntax-entry ?? "." synTable)
	(modify-syntax-entry ?< "." synTable)
	(modify-syntax-entry ?> "." synTable)
	(modify-syntax-entry ?, "." synTable)
	(modify-syntax-entry ?. "." synTable)
	(modify-syntax-entry ?/ "." synTable)
	(modify-syntax-entry ?- "." synTable)
	(modify-syntax-entry ?_ "w" synTable)
	(modify-syntax-entry ?\\ "." synTable) ; \ is path separator
	synTable)
      )

;;; functions

(defun xahk-about ()
  "Show the author, version number, and description about this package."
  (interactive)
  (with-output-to-temp-buffer "*About xahk-mode*"
    (princ
     (concat "Mode name: xahk-mode.\n\n"
             "Author: Xah Lee\n\n"
             "Version: " xahk-mode-version "\n\n"
             "To see inline documentation, type “Alt+x `describe-mode'” while you are in xahk-mode.\n\n"
             "Home page: URL `http://xahlee.info/mswin/emacs_autohotkey_mode.html' \n\n"))))

(defun xahk-lookup-ahk-ref ()
  "Look up current word in AutoHotkey's reference doc.
If a there is a text selection (a phrase), lookup that phrase.
Launches default browser and opens the doc's url."
  (interactive)
  (let (myword myurl)
    (setq myword
          (if (region-active-p)
              (buffer-substring-no-properties (region-beginning) (region-end))
            (thing-at-point 'symbol)))
    (setq myword (replace-regexp-in-string " " "%20" myword))
    (setq myurl (concat "http://www.autohotkey.com/docs/commands/" myword ".htm" ))
    (browse-url myurl)))

;;; font-lock

(defvar xahk-commands nil "AHK keywords.")

(setq xahk-commands '("AllowSameLineComments" "ClipboardTimeout" "CommentFlag" "ErrorStdOut" "EscapeChar" "HotkeyInterval" "HotkeyModifierTimeout" "Hotstring" "IfWinActive" "IfWinExist" "IfWinNotActive" "IfWinNotExist" "Include" "IncludeAgain" "InstallKeybdHook" "InstallMouseHook" "KeyHistory" "LTrim" "MaxHotkeysPerInterval" "MaxMem" "MaxThreads" "MaxThreadsBuffer" "MaxThreadsPerHotkey" "NoEnv" "NoTrayIcon" "Persistent" "SingleInstance" "UseHook" "WinActivateForce" "AutoTrim" "BlockInput" "Break" "Click" "ClipWait" "Continue" "Control" "ControlClick" "ControlFocus" "ControlGet" "ControlGetFocus" "ControlGetPos" "ControlGetText" "ControlMove" "ControlSend" "ControlSendRaw" "ControlSetText" "CoordMode" "Critical" "DetectHiddenText" "DetectHiddenWindows" "Drive" "DriveGet" "DriveSpaceFree" "Edit" "Else" "EnvAdd" "EnvDiv" "EnvGet" "EnvMult" "EnvSet" "EnvSub" "EnvUpdate" "Exit" "ExitApp" "FileAppend" "FileCopy" "FileCopyDir" "FileCreateDir" "FileCreateShortcut" "FileDelete" "FileGetAttrib" "FileGetShortcut" "FileGetSize" "FileGetTime" "FileGetVersion" "FileInstall" "FileMove" "FileMoveDir" "FileRead" "FileReadLine" "FileRecycle" "FileRecycleEmpty" "FileRemoveDir" "FileSelectFile" "FileSelectFolder" "FileSetAttrib" "FileSetTime" "FormatTime" "GetKeyState" "Gosub" "Goto" "GroupActivate" "GroupAdd" "GroupClose" "GroupDeactivate" "Gui" "GuiControl" "GuiControlGet" "Hotkey" "If" "IfEqual" "IfExist" "IfGreater" "IfGreaterOrEqual" "IfInString" "IfLess" "IfLessOrEqual" "IfMsgBox" "IfNotEqual" "IfNotExist" "IfNotInString" "IfWinActive" "IfWinExist" "IfWinNotActive" "IfWinNotExist" "ImageSearch" "IniDelete" "IniRead" "IniWrite" "Input" "InputBox" "KeyHistory" "KeyWait" "ListHotkeys" "ListLines" "ListVars" "Loop" "Menu" "MouseClick" "MouseClickDrag" "MouseGetPos" "MouseMove" "MsgBox" "OnExit" "OutputDebug" "Pause" "PixelGetColor" "PixelSearch" "PostMessage" "Process" "Progress" "Random" "RegDelete" "RegRead" "RegWrite" "Reload" "Repeat" "Return" "Run" "RunAs" "RunWait" "Send" "SendEvent" "SendInput" "SendMessage" "SendMode" "SendPlay" "SendRaw" "SetBatchLines" "SetCapslockState" "SetControlDelay" "SetDefaultMouseSpeed" "SetEnv" "SetFormat" "SetKeyDelay" "SetMouseDelay" "SetNumlockState" "SetScrollLockState" "SetStoreCapslockMode" "SetTimer" "SetTitleMatchMode" "SetWinDelay" "SetWorkingDir" "Shutdown" "Sleep" "Sort" "SoundBeep" "SoundGet" "SoundGetWaveVolume" "SoundPlay" "SoundSet" "SoundSetWaveVolume" "SplashImage" "SplashTextOff" "SplashTextOn" "SplitPath" "StatusBarGetText" "StatusBarWait" "StringCaseSense" "StringGetPos" "StringLeft" "StringLen" "StringLower" "StringMid" "StringReplace" "StringRight" "StringSplit" "StringTrimLeft" "StringTrimRight" "StringUpper" "Suspend" "SysGet" "Thread" "ToolTip" "Transform" "TrayTip" "URLDownloadToFile" "While" "WinActivate" "WinActivateBottom" "WinClose" "WinGet" "WinGetActiveStats" "WinGetActiveTitle" "WinGetClass" "WinGetPos" "WinGetText" "WinGetTitle" "WinHide" "WinKill" "WinMaximize" "WinMenuSelectItem" "WinMinimize" "WinMinimizeAll" "WinMinimizeAllUndo" "WinMove" "WinRestore" "WinSet" "WinSetTitle" "WinShow" "WinWait" "WinWaitActive" "WinWaitClose" "WinWaitNotActive"))

(defvar xahk-functions nil "AHK functions.")

(setq xahk-functions
      '("Abs" "ACos" "Asc" "ASin" "ATan" "Ceil" "Chr" "Cos" "DllCall" "Exp" "FileExist" "Floor" "GetKeyState" "IL_Add" "IL_Create" "IL_Destroy" "InStr" "IsFunc" "IsLabel" "Ln" "Log" "LV_Add" "LV_Delete" "LV_DeleteCol" "LV_GetCount" "LV_GetNext" "LV_GetText" "LV_Insert" "LV_InsertCol" "LV_Modify" "LV_ModifyCol" "LV_SetImageList" "Mod" "NumGet" "NumPut" "OnMessage" "RegExMatch" "RegExReplace" "RegisterCallback" "Round" "SB_SetIcon" "SB_SetParts" "SB_SetText" "Sin" "Sqrt" "StrLen" "SubStr" "Tan" "TV_Add" "TV_Delete" "TV_GetChild" "TV_GetCount" "TV_GetNext" "TV_Get" "TV_GetParent" "TV_GetPrev" "TV_GetSelection" "TV_GetText" "TV_Modify" "VarSetCapacity" "WinActive" "WinExist"))

(defvar xahk-keywords nil "AHK lang keywords.")

(setq xahk-keywords
      '("ACos" "ASin" "ATan" "Abort" "AboveNormal" "Abs" "Add" "All" "Alnum" "Alpha" "AltSubmit" "AltTab" "AltTabAndMenu" "AltTabMenu" "AltTabMenuDismiss" "AlwaysOnTop" "And" "Asc" "AutoSize" "Background" "BackgroundTrans" "BelowNormal" "Between" "BitAnd" "BitNot" "BitOr" "BitShiftLeft" "BitShiftRight" "BitXOr" "Border" "Bottom" "Bottom" "Button" "Buttons" "ByRef" "Cancel" "Cancel" "Capacity" "Caption" "Ceil" "Center" "Center" "Check" "Check3" "Checkbox" "Checked" "CheckedGray" "Choose" "ChooseString" "Chr" "Click" "Close" "Close" "Color" "ComboBox" "Contains" "ControlList" "Cos" "Count" "DDL" "Date" "DateTime" "Days" "Default" "Delete" "DeleteAll" "Delimiter" "Deref" "Destroy" "Digit" "Disable" "Disabled" "DropDownList" "Eject" "Enable" "Enabled" "Error" "ExStyle" "Exist" "Exp" "Expand" "FileSystem" "First" "Flash" "Float" "FloatFast" "Floor" "Focus" "Font" "Grid" "Group" "GroupBox" "GuiClose" "GuiContextMenu" "GuiDropFiles" "GuiEscape" "GuiSize" "HKCC" "HKCR" "HKCU" "HKEY_CLASSES_ROOT" "HKEY_CURRENT_CONFIG" "HKEY_CURRENT_USER" "HKEY_LOCAL_MACHINE" "HKEY_USERS" "HKLM" "HKU" "HScroll" "Hdr" "Hidden" "Hide" "High" "Hours" "ID" "IDLast" "Icon" "IconSmall" "Ignore" "ImageList" "In" "Integer" "IntegerFast" "Interrupt" "Is" "Join" "LTrim" "Label" "Label" "LastFound" "LastFoundExist" "Left" "Limit" "Lines" "List" "ListBox" "ListView" "Ln" "Lock" "Log" "Logoff" "Low" "Lower" "Lowercase" "MainWindow" "Margin" "MaxSize" "Maximize" "MaximizeBox" "MinMax" "MinSize" "Minimize" "MinimizeBox" "Minutes" "Mod" "MonthCal" "Mouse" "Move" "Multi" "NA" "No" "NoActivate" "NoDefault" "NoHide" "NoIcon" "NoMainWindow" "NoSort" "NoSortHdr" "NoStandard" "NoTab" "NoTimers" "Normal" "Not" "Number" "Number" "Off" "Ok" "On" "Or" "OwnDialogs" "Owner" "Parse" "Password" "Password" "Pic" "Picture" "Pixel" "Pos" "Pow" "Priority" "ProcessName" "REG_BINARY" "REG_DWORD" "REG_EXPAND_SZ" "REG_MULTI_SZ" "REG_SZ" "RGB" "RTrim" "Radio" "Range" "Read" "ReadOnly" "Realtime" "Redraw" "Region" "Relative" "Rename" "Report" "Resize" "Restore" "Retry" "Right" "Round" "Screen" "Seconds" "Section" "Section" "Serial" "SetLabel" "ShiftAltTab" "Show" "Sin" "Single" "Slider" "SortDesc" "Sqrt" "Standard" "Status" "StatusBar" "StatusCD" "Style" "Submit" "SysMenu" "Tab" "Tab2" "TabStop" "Tan" "Text" "Text" "Theme" "Tile" "Time" "Tip" "ToggleCheck" "ToggleEnable" "ToolWindow" "Top" "Top" "Topmost" "TransColor" "Transparent" "Tray" "TreeView" "TryAgain" "Type" "UnCheck" "Unicode" "Unlock" "UpDown" "Upper" "Uppercase" "UseErrorLevel" "VScroll" "Vis" "VisFirst" "Visible" "Wait" "WaitClose" "WantCtrlA" "WantF2" "WantReturn" "Wrap" "Xdigit" "Yes" "ahk_class" "ahk_group" "ahk_id" "ahk_pid" "bold" "global" "italic" "local" "norm" "static" "strike" "underline" "xm" "xp" "xs" "ym" "yp" "ys" "{AltDown}" "{AltUp}" "{Blind}" "{Click}" "{CtrlDown}" "{CtrlUp}" "{LWinDown}" "{LWinUp}" "{RWinDown}" "{RWinUp}" "{Raw}" "{ShiftDown}" "{ShiftUp}"))

(defvar xahk-variables nil "AHK variables.")

(setq xahk-variables '("A_AhkPath" "A_AhkVersion" "A_AppData" "A_AppDataCommon" "A_AutoTrim" "A_BatchLines" "A_CaretX" "A_CaretY" "A_ComputerName" "A_ControlDelay" "A_Cursor" "A_DD" "A_DDD" "A_DDDD" "A_DefaultMouseSpeed" "A_Desktop" "A_DesktopCommon" "A_DetectHiddenText" "A_DetectHiddenWindows" "A_EndChar" "A_EventInfo" "A_ExitReason" "A_FormatFloat" "A_FormatInteger" "A_Gui" "A_GuiEvent" "A_GuiControl" "A_GuiControlEvent" "A_GuiHeight" "A_GuiWidth" "A_GuiX" "A_GuiY" "A_Hour" "A_IconFile" "A_IconHidden" "A_IconNumber" "A_IconTip" "A_Index" "A_IPAddress1" "A_IPAddress2" "A_IPAddress3" "A_IPAddress4" "A_ISAdmin" "A_IsCompiled" "A_IsCritical" "A_IsPaused" "A_IsSuspended" "A_KeyDelay" "A_Language" "A_LastError" "A_LineFile" "A_LineNumber" "A_LoopField" "A_LoopFileAttrib" "A_LoopFileDir" "A_LoopFileExt" "A_LoopFileFullPath" "A_LoopFileLongPath" "A_LoopFileName" "A_LoopFileShortName" "A_LoopFileShortPath" "A_LoopFileSize" "A_LoopFileSizeKB" "A_LoopFileSizeMB" "A_LoopFileTimeAccessed" "A_LoopFileTimeCreated" "A_LoopFileTimeModified" "A_LoopReadLine" "A_LoopRegKey" "A_LoopRegName" "A_LoopRegSubkey" "A_LoopRegTimeModified" "A_LoopRegType" "A_MDAY" "A_Min" "A_MM" "A_MMM" "A_MMMM" "A_Mon" "A_MouseDelay" "A_MSec" "A_MyDocuments" "A_Now" "A_NowUTC" "A_NumBatchLines" "A_OSType" "A_OSVersion" "A_PriorHotkey" "A_ProgramFiles" "A_Programs" "A_ProgramsCommon" "A_ScreenHeight" "A_ScreenWidth" "A_ScriptDir" "A_ScriptFullPath" "A_ScriptName" "A_Sec" "A_Space" "A_StartMenu" "A_StartMenuCommon" "A_Startup" "A_StartupCommon" "A_StringCaseSense" "A_Tab" "A_Temp" "A_ThisFunc" "A_ThisHotkey" "A_ThisLabel" "A_ThisMenu" "A_ThisMenuItem" "A_ThisMenuItemPos" "A_TickCount" "A_TimeIdle" "A_TimeIdlePhysical" "A_TimeSincePriorHotkey" "A_TimeSinceThisHotkey" "A_TitleMatchMode" "A_TitleMatchModeSpeed" "A_UserName" "A_WDay" "A_WinDelay" "A_WinDir" "A_WorkingDir" "A_YDay" "A_YEAR" "A_YWeek" "A_YYYY" "Clipboard" "ClipboardAll" "ComSpec" "ErrorLevel" "ProgramFiles" "True" "False" ))

(defvar xahk-keys nil "AHK keywords for keys.")

(setq xahk-keys '("Alt" "AltDown" "AltUp" "AppsKey" "BS" "BackSpace" "Browser_Back" "Browser_Favorites" "Browser_Forward" "Browser_Home" "Browser_Refresh" "Browser_Search" "Browser_Stop" "CapsLock" "Control" "Ctrl" "CtrlBreak" "CtrlDown" "CtrlUp" "Del" "Delete" "Down" "End" "Enter" "Esc" "Escape" "F1" "F10" "F11" "F12" "F13" "F14" "F15" "F16" "F17" "F18" "F19" "F2" "F20" "F21" "F22" "F23" "F24" "F3" "F4" "F5" "F6" "F7" "F8" "F9" "Home" "Ins" "Insert" "Joy1" "Joy10" "Joy11" "Joy12" "Joy13" "Joy14" "Joy15" "Joy16" "Joy17" "Joy18" "Joy19" "Joy2" "Joy20" "Joy21" "Joy22" "Joy23" "Joy24" "Joy25" "Joy26" "Joy27" "Joy28" "Joy29" "Joy3" "Joy30" "Joy31" "Joy32" "Joy4" "Joy5" "Joy6" "Joy7" "Joy8" "Joy9" "JoyAxes" "JoyButtons" "JoyInfo" "JoyName" "JoyPOV" "JoyR" "JoyU" "JoyV" "JoyX" "JoyY" "JoyZ" "LAlt" "LButton" "LControl" "LCtrl" "LShift" "LWin" "LWinDown" "LWinUp" "Launch_App1" "Launch_App2" "Launch_Mail" "Launch_Media" "Left" "MButton" "Media_Next" "Media_Play_Pause" "Media_Prev" "Media_Stop" "NumLock" "Numpad0" "Numpad1" "Numpad2" "Numpad3" "Numpad4" "Numpad5" "Numpad6" "Numpad7" "Numpad8" "Numpad9" "NumpadAdd" "NumpadClear" "NumpadDel" "NumpadDiv" "NumpadDot" "NumpadDown" "NumpadEnd" "NumpadEnter" "NumpadHome" "NumpadIns" "NumpadLeft" "NumpadMult" "NumpadPgdn" "NumpadPgup" "NumpadRight" "NumpadSub" "NumpadUp" "PGDN" "PGUP" "Pause" "PrintScreen" "RAlt" "RButton" "RControl" "RCtrl" "RShift" "RWin" "RWinDown" "RWinUp" "Right" "ScrollLock" "Shift" "ShiftDown" "ShiftUp" "Space" "Tab" "Up" "Volume_Down" "Volume_Mute" "Volume_Up" "WheelDown" "WheelLeft" "WheelRight" "WheelUp" "XButton1" "XButton2"))

(defvar xahk-font-lock-keywords nil )
(let (
      (xahk-commands-regexp (regexp-opt xahk-commands 'words))
      (xahk-functions-regexp (regexp-opt xahk-functions 'words))
      (xahk-keywords-regexp (regexp-opt xahk-keywords 'words))
      (xahk-variables-regexp (regexp-opt xahk-variables 'words))
      (xahk-keys-regexp (regexp-opt xahk-keys 'words)))
  (setq xahk-font-lock-keywords
        `(
          (,xahk-commands-regexp . xahk-mode-command-name-face)
          (,xahk-functions-regexp . font-lock-function-name-face)
          (,xahk-keywords-regexp . font-lock-keyword-face)
          (,xahk-variables-regexp . font-lock-variable-name-face)
          (,xahk-keys-regexp . font-lock-constant-face)
          ;; note: order matters
          )))

;; keyword completion
(defvar xahk-kwdList nil "AHK keywords.")

(setq xahk-kwdList (make-hash-table :test 'equal))
(mapc (lambda (x) (puthash x t xahk-kwdList)) xahk-commands)
(mapc (lambda (x) (puthash x t xahk-kwdList)) xahk-functions)
(mapc (lambda (x) (puthash x t xahk-kwdList)) xahk-keywords)
(mapc (lambda (x) (puthash x t xahk-kwdList)) xahk-variables)
(mapc (lambda (x) (puthash x t xahk-kwdList)) xahk-keys)
(put 'xahk-kwdList 'risky-local-variable t)

(defun xahk-complete-symbol ()
  "Perform keyword completion on word before cursor.
Keywords include all AHK's event handlers, functions, and CONSTANTS."
  (interactive)
  (let ((posEnd (point))
        (meat (thing-at-point 'symbol))
        maxMatchResult)

    (when (not meat) (setq meat ""))

    (setq maxMatchResult (try-completion meat xahk-kwdList))
    (cond ((eq maxMatchResult t))
          ((null maxMatchResult)
           (message "Can't find completion for “%s”" meat)
           (ding))
          ((not (string= meat maxMatchResult))
           (delete-region (- posEnd (length meat)) posEnd)
           (insert maxMatchResult))
          (t (message "Making completion list...")
             (with-output-to-temp-buffer "*Completions*"
               (display-completion-list
                (all-completions meat xahk-kwdList)))
             (message "Making completion list...%s" "done")))))

;; clear memory
(setq xahk-commands nil)
(setq xahk-functions nil)
(setq xahk-keywords nil)
(setq xahk-variables nil)
(setq xahk-keys nil)

;;;###autoload
(defun xahk-mode ()
  "Major mode for editing AutoHotkey script (AHK).

Shortcuts             Command Name
\\[comment-dwim]       `comment-dwim'

\\[xahk-complete-symbol]      `xahk-complete-symbol'

\\[xahk-lookup-ahk-ref]     `xahk-lookup-ahk-ref'

Complete documentation at URL `http://xahlee.info/mswin/emacs_autohotkey_mode.html'."
  (interactive)
  (kill-all-local-variables)

  (c-mode) ; for indentation
  (setq major-mode 'xahk-mode)
  (setq mode-name "∑AHK")
  (set-syntax-table xahk-mode-syntax-table)
  (use-local-map xahk-mode-map)

  (setq-local comment-start "; ")
  (setq-local comment-end "")

  (make-local-variable 'font-lock-defaults)
  (setq font-lock-defaults '((xahk-font-lock-keywords) nil t))

  (run-mode-hooks 'xahk-mode-hook))

(defalias 'ahk-mode 'xahk-mode)
(add-to-list 'auto-mode-alist '("\\.ahk\\'" . xahk-mode))

(provide 'xahk-mode)

;;; xahk-mode.el ends here

;;; -*- lexical-binding: t -*-

;; MIT License
;; Copyright (c) 2017 Iskander Sharipov
;; Permission is hereby granted, free of charge, to any person obtaining a copy
;; of this software and associated documentation files (the "Software"), to deal
;; in the Software without restriction, including without limitation the rights
;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;; copies of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:
;; The above copyright notice and this permission notice shall be included in all
;; copies or substantial portions of the Software.
;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(defconst mv--max-count 10) ;; Arbitrary limit

(defun mv--var (index)
  "Get return value variable symbol by INDEX"
  (when (>= index mv--max-count)
    (error "Index %d is too high (%d is max)" index (1- mv--max-count)))
  (intern (format "mv--%d" index)))

(dotimes (i mv--max-count)
  (eval `(defvar ,(mv--var i) nil)))

(defmacro mv-ret (&rest xs)
  "Return multiple values from a function. 
Results can be used using `mv-let' macro."
  (let ((forms nil)
        (values (cdr xs))
        (i 0))
    (dolist (value values)
      (push `(setq ,(mv--var i) ,value) forms)
      (setq i (1+ i)))
    `(progn
       ,@(nreverse forms)
       ,(car xs))))

(defmacro mv-let (name-list mv-expr &rest body)
  "Call MV-EXPR and bind each returned value to the corresponding
symbol in NAME-LIST. Bound variables are visible for each form inside BODY."
  (declare (indent 2))
  (let ((forms nil)
        (i 0))
    ;; We can not ignore first expression even if it is bound to "_".
    (push `(,(pop name-list) ,mv-expr) forms)
    (dolist (name name-list)
      (unless (eq name '_)
        (push `(,name ,(mv--var i)) forms))
      (setq i (1+ i)))
    `(let ,(nreverse forms)
       ,@body)))

;; (defun test-3 (a b c)
;;   (mv-ret c b a))

;; (mv-let (a b c) (test-3 1 2 3)
;;   (format "%d %d %d" a b c)) ;; => "3 2 1"

;; (let ((lexical-binding t))
;;   (benchmark-run-compiled 1000000
;;     (mv-let (a b c) (mv-ret 1 2 3)
;;       (ignore a b c))))


;;; idomenu.el --- imenu tag selection a la ido
;;
;; Copyright (C) 2010 Georg Brandl
;;
;; Author: Georg Brandl <georg@python.org>
;; Version: 0.1
;;
;; This file is NOT part of GNU Emacs.
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 2
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;;
;;; Commentary:
;;
;; This package provides the `idomenu' command for selecting an imenu tag using
;; ido completion.  The buffer needs to have support for imenu already enabled.
;;
;; Add something like the following to your .emacs:
;;
;; (autoload 'idomenu "idomenu" nil t)
;;
;;; Code:

(require 'ido)
(require 'imenu)

(defun idomenu--guess-default (index-alist symbol)
  "Guess a default choice from the given symbol."
  (catch 'found
    (let ((regex (concat "\\_<" (regexp-quote symbol) "\\_>")))
      (dolist (item index-alist)
        (if (string-match regex (car item)) (throw 'found (car item)))))))

(defun idomenu--read (index-alist &optional prompt guess)
  "Read a choice from an Imenu alist via Ido."
  (let* ((symatpt (thing-at-point 'symbol))
         (default (and guess symatpt (idomenu--guess-default index-alist symatpt)))
         (names (mapcar 'car index-alist))
         (name (ido-completing-read (or prompt "imenu ") names
                                    nil t nil nil default))
         (choice (assoc name index-alist)))
    (if (imenu--subalist-p choice)
        (idomenu--read (cdr choice) prompt nil)
      choice)))

(defun idomenu--trim (str)
  "Trim leading and tailing whitespace from STR."
  (let ((s (if (symbolp str) (symbol-name str) str)))
    (replace-regexp-in-string "\\(^[[:space:]\n]*\\|[[:space:]\n]*$\\)" "" s)))

(defun idomenu--trim-alist (index-alist)
  "There must be a better way to apply a function to all cars of an alist"
  (mapcar (lambda (pair) (cons (idomenu--trim (car pair)) (cdr pair)))
	  index-alist))

;;;###autoload
(defun idomenu ()
  "Switch to a buffer-local tag from Imenu via Ido."
  (interactive)
  ;; ido initialization
  (ido-init-completion-maps)
  (add-hook 'minibuffer-setup-hook 'ido-minibuffer-setup)
  (add-hook 'choose-completion-string-functions 'ido-choose-completion-string)
  (add-hook 'kill-emacs-hook 'ido-kill-emacs-hook)
  ;; set up ido completion list
  (let ((index-alist (cdr (imenu--make-index-alist))))
    (if (equal index-alist '(nil))
        (message "No imenu tags in buffer")
      (imenu (idomenu--read (idomenu--trim-alist index-alist) nil t)))))

(provide 'idomenu)
;;; idomenu.el ends here
